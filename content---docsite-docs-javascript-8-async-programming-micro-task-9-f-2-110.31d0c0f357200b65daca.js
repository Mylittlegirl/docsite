(window.webpackJsonp=window.webpackJsonp||[]).push([[81],{190:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return o})),t.d(n,"rightToc",(function(){return i})),t.d(n,"default",(function(){return p}));t(0);var a=t(390);function r(){return(r=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e}).apply(this,arguments)}function c(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},c=Object.keys(e);for(a=0;a<c.length;a++)t=c[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var c=Object.getOwnPropertySymbols(e);for(a=0;a<c.length;a++)t=c[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var o={title:"微任务",sidebar_label:"微任务"},i=[{value:"前言",id:"前言",children:[]},{value:"Promise和async立即执行",id:"promise和async立即执行",children:[]},{value:"await做了什么",id:"await做了什么",children:[]}],l={rightToc:i},s="wrapper";function p(e){var n=e.components,t=c(e,["components"]);return Object(a.b)(s,r({},l,t,{components:n,mdxType:"MDXLayout"}),Object(a.b)("h2",{id:"前言"},"前言"),Object(a.b)("p",null,"微任务（micro-task/job）是在",Object(a.b)("inlineCode",{parentName:"p"},"es6和node环境"),"中出现的一个任务类型，如果不考虑es6和node环境的话，我们只需要理解宏任务事件循环的执行过程就已经足够了，但是到了es6和node环境，我们就需要理解微任务的执行顺序了。"),Object(a.b)("p",null,"微任务（micro-task）的API主要有:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"Promise.then"),Object(a.b)("li",{parentName:"ul"},"async/await"),Object(a.b)("li",{parentName:"ul"},"process.nextTick(Node.js 环境)"),Object(a.b)("li",{parentName:"ul"},"Object.observer"),Object(a.b)("li",{parentName:"ul"},"MutationObserver")),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"微任务可以理解是在当前宏任务执行结束后立即执行的任务。也就是说，在当前宏任务后，下一个宏任务之前，在渲染之前。")),Object(a.b)("p",null,"所以它的响应速度相比",Object(a.b)("inlineCode",{parentName:"p"},"setTimeout（setTimeout是task）"),"会更快，因为无需等渲染。也就是说，在某一个macrotask执行完后，就会将在它执行期间产生的所有microtask都执行完毕（在渲染前）。"),Object(a.b)("h2",{id:"promise和async立即执行"},"Promise和async立即执行"),Object(a.b)("p",null,"我们知道Promise中的异步体现在then和catch中，所以写在Promise中的代码是被当做同步任务立即执行的。而在async/await中，在出现await出现之前，其中的代码也是立即执行的。那么出现了await时候发生了什么呢？"),Object(a.b)("h2",{id:"await做了什么"},"await做了什么"),Object(a.b)("p",null,"从字面意思上看await就是等待，await 等待的是一个表达式，这个表达式的返回值可以是一个promise对象也可以是其他值。"),Object(a.b)("p",null,"很多人以为await会一直等待之后的表达式执行完之后才会继续执行后面的代码，实际上await是一个让出线程的标志。await后面的表达式会先执行一遍，将await后面的代码加入到microtask中，然后就会跳出整个async函数来执行后面的代码。"),Object(a.b)("p",null,"由于async await 本身就是promise+generator的语法糖，所以await后面的代码是microtask。所以对于本题中的"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"async function async1() {\n    console.log('async1 start');\n    await async2();\n    console.log('async1 end');\n}\n\n")),Object(a.b)("p",null,"等价于"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"async function async1() {\n    console.log('async1 start');\n    Promise.resolve(async2()).then(() => {\n    console.log('async1 end');\n    })\n}\n")),Object(a.b)("p",null,"可以简单理解为："),Object(a.b)("p",null,"async函数在await之前的代码同步执行（可以理解为await之前的代码属于new Promise时传入的代码）\nawait之后的所有代码都是在Promise.then中的回调"))}p.isMDXComponent=!0},390:function(e,n,t){"use strict";t.d(n,"a",(function(){return i})),t.d(n,"b",(function(){return u}));var a=t(0),r=t.n(a),c=r.a.createContext({}),o=function(e){var n=r.a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):Object.assign({},n,e)),t},i=function(e){var n=o(e.components);return r.a.createElement(c.Provider,{value:n},e.children)};var l="mdxType",s={inlineCode:"code",wrapper:function(e){var n=e.children;return r.a.createElement(r.a.Fragment,{},n)}},p=Object(a.forwardRef)((function(e,n){var t=e.components,a=e.mdxType,c=e.originalType,i=e.parentName,l=function(e,n){var t={};for(var a in e)Object.prototype.hasOwnProperty.call(e,a)&&-1===n.indexOf(a)&&(t[a]=e[a]);return t}(e,["components","mdxType","originalType","parentName"]),p=o(t),u=a,b=p[i+"."+u]||p[u]||s[u]||c;return t?r.a.createElement(b,Object.assign({},{ref:n},l,{components:t})):r.a.createElement(b,Object.assign({},{ref:n},l))}));function u(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var c=t.length,o=new Array(c);o[0]=p;var i={};for(var s in n)hasOwnProperty.call(n,s)&&(i[s]=n[s]);i.originalType=e,i[l]="string"==typeof e?e:a,o[1]=i;for(var u=2;u<c;u++)o[u]=t[u];return r.a.createElement.apply(null,o)}return r.a.createElement.apply(null,t)}p.displayName="MDXCreateElement"}}]);