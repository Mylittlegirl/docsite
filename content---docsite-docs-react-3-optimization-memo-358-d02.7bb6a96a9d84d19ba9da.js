(window.webpackJsonp=window.webpackJsonp||[]).push([[137],{280:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return r})),t.d(n,"rightToc",(function(){return i})),t.d(n,"default",(function(){return s}));t(58),t(31),t(22),t(23),t(59),t(0);var a=t(553);function o(){return(o=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e}).apply(this,arguments)}var r={id:"memo",title:"\u8bb0\u5fc6\u5316\u7ec4\u4ef6",sidebar_label:"\u8bb0\u5fc6\u5316\u7ec4\u4ef6"},i=[{value:"React.memo",id:"reactmemo",children:[]},{value:"useMemo hook",id:"usememo-hook",children:[]}],c={rightToc:i},p="wrapper";function s(e){var n=e.components,t=function(e,n){if(null==e)return{};var t,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,["components"]);return Object(a.b)(p,o({},c,t,{components:n,mdxType:"MDXLayout"}),Object(a.b)("h2",{id:"reactmemo"},Object(a.b)("inlineCode",{parentName:"h2"},"React.memo")),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"const MyComponent = React.memo(function MyComponent(props) {\n  /* render using props */\n});\n")),Object(a.b)("p",null,Object(a.b)("inlineCode",{parentName:"p"},"React.memo")," is a ",Object(a.b)("a",o({parentName:"p"},{href:"/docs/higher-order-components.html"}),"higher order component"),". It's similar to ",Object(a.b)("a",o({parentName:"p"},{href:"#reactpurecomponent"}),Object(a.b)("inlineCode",{parentName:"a"},"React.PureComponent"))," but for function components instead of classes."),Object(a.b)("p",null,"If your function component renders the same result given the same props, you can wrap it in a call to ",Object(a.b)("inlineCode",{parentName:"p"},"React.memo")," for a performance boost in some cases by memoizing the result. This means that React will skip rendering the component, and reuse the last rendered result."),Object(a.b)("p",null,"By default it will only shallowly compare complex objects in the props object. If you want control over the comparison, you can also provide a custom comparison function as the second argument."),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"function MyComponent(props) {\n  /* render using props */\n}\nfunction areEqual(prevProps, nextProps) {\n  /*\n  return true if passing nextProps to render would return\n  the same result as passing prevProps to render,\n  otherwise return false\n  */\n}\nexport default React.memo(MyComponent, areEqual);\n")),Object(a.b)("p",null,"This method only exists as a ",Object(a.b)("strong",{parentName:"p"},Object(a.b)("a",o({parentName:"strong"},{href:"/docs/optimizing-performance.html"}),"performance optimization"),"."),' Do not rely on it to "prevent" a render, as this can lead to bugs.'),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"Note"),Object(a.b)("p",{parentName:"blockquote"},"Unlike the ",Object(a.b)("a",o({parentName:"p"},{href:"/docs/react-component.html#shouldcomponentupdate"}),Object(a.b)("inlineCode",{parentName:"a"},"shouldComponentUpdate()"))," method on class components, the ",Object(a.b)("inlineCode",{parentName:"p"},"areEqual")," function returns ",Object(a.b)("inlineCode",{parentName:"p"},"true")," if the props are equal and ",Object(a.b)("inlineCode",{parentName:"p"},"false")," if the props are not equal. This is the inverse from ",Object(a.b)("inlineCode",{parentName:"p"},"shouldComponentUpdate"),".")),Object(a.b)("h2",{id:"usememo-hook"},Object(a.b)("inlineCode",{parentName:"h2"},"useMemo")," hook"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-js"}),"const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);\n")),Object(a.b)("p",null,"Returns a ",Object(a.b)("a",o({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Memoization"}),"memoized")," value."),Object(a.b)("p",null,'Pass a "create" function and an array of dependencies. ',Object(a.b)("inlineCode",{parentName:"p"},"useMemo")," will only recompute the memoized value when one of the dependencies has changed. This optimization helps to avoid expensive calculations on every render."),Object(a.b)("p",null,"Remember that the function passed to ",Object(a.b)("inlineCode",{parentName:"p"},"useMemo")," runs during rendering. Don't do anything there that you wouldn't normally do while rendering. For example, side effects belong in ",Object(a.b)("inlineCode",{parentName:"p"},"useEffect"),", not ",Object(a.b)("inlineCode",{parentName:"p"},"useMemo"),"."),Object(a.b)("p",null,"If no array is provided, a new value will be computed on every render."),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"You may rely on ",Object(a.b)("inlineCode",{parentName:"strong"},"useMemo")," as a performance optimization, not as a semantic guarantee."),' In the future, React may choose to "forget" some previously memoized values and recalculate them on next render, e.g. to free memory for offscreen components. Write your code so that it still works without ',Object(a.b)("inlineCode",{parentName:"p"},"useMemo")," \u2014 and then add it to optimize performance."),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"Note"),Object(a.b)("p",{parentName:"blockquote"},"The array of dependencies is not passed as arguments to the function. Conceptually, though, that's what they represent: every value referenced inside the function should also appear in the dependencies array. In the future, a sufficiently advanced compiler could create this array automatically."),Object(a.b)("p",{parentName:"blockquote"},"We recommend using the ",Object(a.b)("a",o({parentName:"p"},{href:"https://github.com/facebook/react/issues/14920"}),Object(a.b)("inlineCode",{parentName:"a"},"exhaustive-deps"))," rule as part of our ",Object(a.b)("a",o({parentName:"p"},{href:"https://www.npmjs.com/package/eslint-plugin-react-hooks#installation"}),Object(a.b)("inlineCode",{parentName:"a"},"eslint-plugin-react-hooks"))," package. It warns when dependencies are specified incorrectly and suggests a fix.")))}s.isMDXComponent=!0},553:function(e,n,t){"use strict";t.d(n,"a",(function(){return c})),t.d(n,"b",(function(){return m}));var a=t(0),o=t.n(a),r=o.a.createContext({}),i=function(e){var n=o.a.useContext(r),t=n;return e&&(t="function"==typeof e?e(n):Object.assign({},n,e)),t},c=function(e){var n=i(e.components);return o.a.createElement(r.Provider,{value:n},e.children)};var p="mdxType",s={inlineCode:"code",wrapper:function(e){var n=e.children;return o.a.createElement(o.a.Fragment,{},n)}},l=Object(a.forwardRef)((function(e,n){var t=e.components,a=e.mdxType,r=e.originalType,c=e.parentName,p=function(e,n){var t={};for(var a in e)Object.prototype.hasOwnProperty.call(e,a)&&-1===n.indexOf(a)&&(t[a]=e[a]);return t}(e,["components","mdxType","originalType","parentName"]),l=i(t),m=a,u=l[c+"."+m]||l[m]||s[m]||r;return t?o.a.createElement(u,Object.assign({},{ref:n},p,{components:t})):o.a.createElement(u,Object.assign({},{ref:n},p))}));function m(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var r=t.length,i=new Array(r);i[0]=l;var c={};for(var s in n)hasOwnProperty.call(n,s)&&(c[s]=n[s]);c.originalType=e,c[p]="string"==typeof e?e:a,i[1]=c;for(var m=2;m<r;m++)i[m]=t[m];return o.a.createElement.apply(null,i)}return o.a.createElement.apply(null,t)}l.displayName="MDXCreateElement"}}]);