(window.webpackJsonp=window.webpackJsonp||[]).push([[97],{228:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return o})),t.d(n,"rightToc",(function(){return p})),t.d(n,"default",(function(){return u}));t(0);var r=t(438);function a(){return(a=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r])}return e}).apply(this,arguments)}function c(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},c=Object.keys(e);for(r=0;r<c.length;r++)t=c[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var c=Object.getOwnPropertySymbols(e);for(r=0;r<c.length;r++)t=c[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var o={title:"创建实例",sidebar_label:"创建实例"},p=[{value:"从构造函数创建：new",id:"从构造函数创建：new",children:[{value:"new 命令的原理",id:"new-命令的原理",children:[]}]},{value:"从实例创建：constructor",id:"从实例创建：constructor",children:[]},{value:"从实例创建：Object.create",id:"从实例创建：objectcreate",children:[]}],b={rightToc:p},l="wrapper";function u(e){var n=e.components,t=c(e,["components"]);return Object(r.b)(l,a({},b,t,{components:n,mdxType:"MDXLayout"}),Object(r.b)("h2",{id:"从构造函数创建：new"},"从构造函数创建：new"),Object(r.b)("p",null,"new 会",Object(r.b)("strong",{parentName:"p"},"劫持"),"所有普通函数并用构造对象的形式来调用它。"),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"new命令使用需要注意的点：")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"new命令总是返回一个对象，要么是实例对象，要么是return语句指定的对象。比如return语句返回的是字符串，所以new命令就忽略了该语句，返回实例对象this。"),Object(r.b)("li",{parentName:"ul"},"new命令执行时，构造函数内部的this，就代表了新生成的实例对象，如果没有使用new 调用该函数那么this会指向执行上下文，比如全局对象。"),Object(r.b)("li",{parentName:"ul"},"new命令本身就可以执行构造函数，所以后面的构造函数可以带括号，也可以不带括号。下面两行代码是等价的，但是为了表示这里是函数调用，推荐使用括号。")),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{className:"language-js"}),"// 推荐的写法\nvar v = new Vehicle();\n// 不推荐的写法\nvar v = new Vehicle;\n")),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"如何保证构造函数必须与new命令一起使用？")),Object(r.b)("p",null,"方法一：构造函数内部使用严格模式，即第一行加上use strict。这样的话，一旦忘了使用new命令，直接调用构造函数就会报错。"),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{className:"language-js"}),"function Fubar(foo, bar){\n  'use strict';\n this._foo = foo;\n this._bar = bar;\n}\n\nFubar()\n// TypeError: Cannot set property '_foo' of undefined\n")),Object(r.b)("p",null,"由于严格模式中，",Object(r.b)("strong",{parentName:"p"},"函数内部的this不指向全局对象"),"，默认等于",Object(r.b)("inlineCode",{parentName:"p"},"undefined"),"。"),Object(r.b)("p",null,"方法二：函数内部可以使用new.target属性。如果当前函数是new命令调用，new.target指向当前函数，否则为undefined。"),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{className:"language-js"}),"function f() {\n console.log(new.target === f);\n}\n\nf() // false\nnew f() // true\n")),Object(r.b)("p",null,"使用这个属性，可以判断函数调用的时候，是否使用new命令。"),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{className:"language-js"}),"function f() {\n if (!new.target) {\n   throw new Error('请使用 new 命令调用！');\n }\n // ...\n}\n\nf() // Uncaught Error: 请使用 new 命令调用！\n")),Object(r.b)("h3",{id:"new-命令的原理"},"new 命令的原理"),Object(r.b)("p",null,"使用new命令时，它后面的函数依次执行下面的步骤。"),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},"创建一个空对象，作为将要返回的对象实例。"),Object(r.b)("li",{parentName:"ol"},"将这个空对象的原型，指向构造函数的prototype属性。"),Object(r.b)("li",{parentName:"ol"},"将这个空对象赋值给函数内部的this关键字。"),Object(r.b)("li",{parentName:"ol"},"开始执行构造函数内部的代码。")),Object(r.b)("p",null,"就是说，构造函数内部，",Object(r.b)("strong",{parentName:"p"},"this指的是一个新生成的空对象"),"，所有针对this的操作，都会发生在这个空对象上。构造函数之所以叫“构造函数”，就是说这个函数的目的，",Object(r.b)("strong",{parentName:"p"},"就是操作一个空对象（即this对象），将其“构造”为需要的样子"),"。"),Object(r.b)("p",null,"new命令简化的内部流程，可以用下面的代码表示。"),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{className:"language-js"}),"function _new(/* 构造函数 */ constructor, /* 构造函数参数 */ params) {\n // 将 arguments 对象转为数组\n var args = [].slice[al].call(arguments);\n // 取出构造函数\n var constructor = args.shift()[am];\n // 创建一个空对象，继承构造函数的 prototype 属性\n var context[an] = Object.create(constructor.prototype);\n // 执行构造函数\n var result = constructor.apply(context, args[ao]);\n // 如果返回结果是对象，就直接返回，否则返回 context 对象\n return (typeof result === 'object' && result != null) ? result : context;\n}\n\n// 实例\nvar actor = _new(Person, '张三', 28);\n")),Object(r.b)("h2",{id:"从实例创建：constructor"},"从实例创建：constructor"),Object(r.b)("p",null,"先介绍一下",Object(r.b)("inlineCode",{parentName:"p"},"prototype"),"对象里的",Object(r.b)("inlineCode",{parentName:"p"},"constructor"),"属性，默认指向",Object(r.b)("inlineCode",{parentName:"p"},"prototype"),"对象所在的构造函数。请注意",Object(r.b)("strong",{parentName:"p"},"由构造函数创建出来的实例实际上是没有",Object(r.b)("inlineCode",{parentName:"strong"},"constructor"),"属性，因为它是",Object(r.b)("inlineCode",{parentName:"strong"},"prototype"),"的一个属性"),"，而",Object(r.b)("inlineCode",{parentName:"p"},"prototype"),"是构造函数所特有的。但实例可以通过",Object(r.b)("strong",{parentName:"p"},"原型链委托继承"),"的方式来继承该属性："),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{className:"language-js"}),"function P() {}\nvar p = new P();\n\np.constructor === P // true\np.constructor === P.prototype.constructor // true\np.hasOwnProperty('constructor') // false\n")),Object(r.b)("p",null,"上面代码中，p是构造函数P的实例对象，但是p自身没有",Object(r.b)("inlineCode",{parentName:"p"},"constructor"),"属性，该属性其实是读取原型链上面的",Object(r.b)("inlineCode",{parentName:"p"},"P.prototype.constructor"),"属性。"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"constructor"),"属性的作用是，可以得知某个实例对象，到底是哪一个构造函数产生的。"),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{className:"language-js"}),"function F() {};\nvar f = new F();\n\nf.constructor === F // true\nf.constructor === RegExp // false\n")),Object(r.b)("p",null,"构造函数作为模板，可以生成实例对象。但是，",Object(r.b)("strong",{parentName:"p"},"有时拿不到构造函数，只能拿到一个现有的实例。我们可以用a的",Object(r.b)("inlineCode",{parentName:"strong"},"constructor"),"方法去创建一个新的实例。")),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{className:"language-js"}),"function A() {}\nvar a = new A();\n\nvar b = new a.constructor(); // 其实相当于new A()\nb instanceof A // true\n")),Object(r.b)("div",null,Object(r.b)("img",{width:"436",src:"https://cosmos-x.oss-cn-hangzhou.aliyuncs.com/image15.png"})),Object(r.b)("p",null,"这使得在实例方法中，调用自身的构造函数成为可能。"),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{className:"language-js"}),"Constructor.prototype.createCopy = function () {\n return new this.constructor();\n};\n\n")),Object(r.b)("p",null,"上面代码中，createCopy方法调用构造函数，新建另一个实例。"),Object(r.b)("h2",{id:"从实例创建：objectcreate"},"从实例创建：Object.create"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"Object.create")," 主要是用来从",Object(r.b)("strong",{parentName:"p"},"一个对象创建出另一个对象，并且保留该对象的原型链继承关系"),"。它会凭空创建一个“新”对象并把新对象内部的",Object(r.b)("inlineCode",{parentName:"p"},"__proto_"),"_关联到你指定的对象。它以现有的对象为基础，而在JS中无论是字面量对象还是new出来的对象实例本质上都是Object构造函数的实例。所以",Object(r.b)("strong",{parentName:"p"},"从一个对象创建出另一个对象可以理解成“从一个实例duplicate另一个实例实例”。")),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{className:"language-js"}),"var person1 = {\n name: '张三',\n age: 38,\n greeting: function() {\n   console.log('Hi! I\\'m ' + this.name + '.');\n }\n};\n\nvar person2 = Object.create(person1);\n\nperson2.name // 张三\nperson2.greeting() // Hi! I'm 张三\n")),Object(r.b)("p",null,"上面代码中，对象person1是person2的模板，后者继承了前者的属性和方法。"),Object(r.b)("p",null,"相关拓展：",Object(r.b)("a",a({parentName:"p"},{href:"https://www.google.com/url?q=https://blog.csdn.net/blueblueskyhua/article/details/73135938&sa=D&ust=1570507768637000"}),"Object.create 和new区别")))}u.isMDXComponent=!0},438:function(e,n,t){"use strict";t.d(n,"a",(function(){return p})),t.d(n,"b",(function(){return s}));var r=t(0),a=t.n(r),c=a.a.createContext({}),o=function(e){var n=a.a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):Object.assign({},n,e)),t},p=function(e){var n=o(e.components);return a.a.createElement(c.Provider,{value:n},e.children)};var b="mdxType",l={inlineCode:"code",wrapper:function(e){var n=e.children;return a.a.createElement(a.a.Fragment,{},n)}},u=Object(r.forwardRef)((function(e,n){var t=e.components,r=e.mdxType,c=e.originalType,p=e.parentName,b=function(e,n){var t={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&-1===n.indexOf(r)&&(t[r]=e[r]);return t}(e,["components","mdxType","originalType","parentName"]),u=o(t),s=r,i=u[p+"."+s]||u[s]||l[s]||c;return t?a.a.createElement(i,Object.assign({},{ref:n},b,{components:t})):a.a.createElement(i,Object.assign({},{ref:n},b))}));function s(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var c=t.length,o=new Array(c);o[0]=u;var p={};for(var l in n)hasOwnProperty.call(n,l)&&(p[l]=n[l]);p.originalType=e,p[b]="string"==typeof e?e:r,o[1]=p;for(var s=2;s<c;s++)o[s]=t[s];return a.a.createElement.apply(null,o)}return a.a.createElement.apply(null,t)}u.displayName="MDXCreateElement"}}]);