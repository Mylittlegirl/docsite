(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{104:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return l})),t.d(n,"rightToc",(function(){return p})),t.d(n,"default",(function(){return u}));t(0);var r=t(147);function a(){return(a=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r])}return e}).apply(this,arguments)}function o(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l={id:"pure-component",title:"纯组件",sidebar_label:"纯组件"},p=[{value:"PureRender",id:"purerender",children:[{value:"shouldComponentUpdate 作用",id:"shouldcomponentupdate-作用",children:[]}]},{value:"PureRender 本质",id:"purerender-本质",children:[]},{value:"组件提纯",id:"组件提纯",children:[]}],c={rightToc:p},b="wrapper";function u(e){var n=e.components,t=o(e,["components"]);return Object(r.b)(b,a({},c,t,{components:n,mdxType:"MDXLayout"}),Object(r.b)("h2",{id:"purerender"},"PureRender"),Object(r.b)("p",null,"PureRender 的核心在于 ",Object(r.b)("inlineCode",{parentName:"p"},"shouldComponentUpdate")," 方法"),Object(r.b)("h3",{id:"shouldcomponentupdate-作用"},"shouldComponentUpdate 作用"),Object(r.b)("p",null,"shouldComponentUpdate 是 PureRender 的关键之所在，这个生命周期钩子函数决定了需不需要执行 render 方法。一个组件的状态更新到真实 dom 的更新大致流程如下："),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{className:"language-text"}),"SCU(shouldComponentUpdate)  --true--\x3e  render  --true--\x3e  vDOMEq  --true--\x3e realDOM\n")),Object(r.b)("p",null,"以 ",Object(r.b)("a",a({parentName:"p"},{href:"https://doc.react-china.org/docs/optimizing-performance.html#shouldcomponentupdate%E5%BA%94%E7%94%A8"}),"React 官方的例子")," 为例，补充说明如下："),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"SCU"),"表明了",Object(r.b)("inlineCode",{parentName:"li"},"shouldComponentUpdate"),"的返回内容，绿色代表 true，会重新执行 render 方法；红色代表 false，不会执行 render 方法。"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"vDOMEq"),"表明了执行 v-diff 后待渲染的 v-dom 与原始 v-dom 是否相等，绿色代表相等，红色代表不等，需要更新 dom。"),Object(r.b)("li",{parentName:"ul"},"圆圈的颜色表明这个组件是否需要更新 dom，红色和 ",Object(r.b)("inlineCode",{parentName:"li"},"vDOMEq")," 的值的颜色一致。")),Object(r.b)("p",null,Object(r.b)("img",a({parentName:"p"},{src:"https://raw.githubusercontent.com/ThinkBucket/oss/master/should-component-update-1.png",alt:"shouldComponentUpdate"}))),Object(r.b)("p",null,"由于 C2 的",Object(r.b)("inlineCode",{parentName:"p"},"shouldComponentUpdate"),"返回了",Object(r.b)("inlineCode",{parentName:"p"},"false"),"，React 不会调用 C2 的 render 方法，也就不会生成 v-dom，甚至不会在 C4 和 C5 上调用",Object(r.b)("inlineCode",{parentName:"p"},"shouldComponentUpdate"),"。"),Object(r.b)("p",null,"对 C1 和 C3 来说，",Object(r.b)("inlineCode",{parentName:"p"},"shouldComponentUpdate"),"返回了",Object(r.b)("inlineCode",{parentName:"p"},"true"),"，因此 React 会深入到分支中并检查它们。C6 的",Object(r.b)("inlineCode",{parentName:"p"},"shouldComponentUpdate"),"返回了",Object(r.b)("inlineCode",{parentName:"p"},"true"),"，然后进行 v-diff，由于 ",Object(r.b)("inlineCode",{parentName:"p"},"vDOMEq")," 返回 false，React 会更新这个真实的 DOM 节点。"),Object(r.b)("p",null,"最后一个有趣的情况是 C8，",Object(r.b)("inlineCode",{parentName:"p"},"SCU")," 为 true 会调用 render 方法进行 v-diff，但是由于",Object(r.b)("inlineCode",{parentName:"p"},"vDOMEq")," 返回 true，因此它并没有更新这个真实的 DOM 节点。"),Object(r.b)("p",null,"分析完以上所有过程，我们会发现 React ",Object(r.b)("strong",{parentName:"p"},"只需更新 C6 的真实 DOM 节点"),"，因为它是不可避免的。对C8来说，它通过 v-diff 避免了更新真实 DOM，对 C2 的子树和 C7，它们甚至都没有执行比较，因为我们设置了",Object(r.b)("inlineCode",{parentName:"p"},"shouldComponentUpdate"),"为",Object(r.b)("inlineCode",{parentName:"p"},"false"),"，",Object(r.b)("inlineCode",{parentName:"p"},"render"),"没有被调用。"),Object(r.b)("blockquote",null,Object(r.b)("p",{parentName:"blockquote"},Object(r.b)("strong",{parentName:"p"},"注意"),"：虽然 C1 和 C3 节点被标记为红色，但实际更新真实 DOM 的时候只会更新 C6 节点。")),Object(r.b)("h2",{id:"purerender-本质"},"PureRender 本质"),Object(r.b)("p",null,"PureRender 的本质就是把 shouldComponentUpdate 函数用浅比较（shallowCompare）进行重写。"),Object(r.b)("p",null,"以下是 React 中 ",Object(r.b)("inlineCode",{parentName:"p"},"shallowCompare.js")," 的核心源码："),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{className:"language-javascript"}),"function shallowCompare(instance, nextProps, nextState) {\n  return !shallowEqual(instance.props, nextProps) || !shallowEqual(instance.state, nextState);\n}\n")),Object(r.b)("p",null,"\0我们可以看到 shallowCompare 实际返回的是 shallowEqual 的",Object(r.b)("strong",{parentName:"p"},"取反"),"结果，那 shallowEqual 的源码则是核心所在，react 的 shallowEqual 其实就是引用的 ",Object(r.b)("inlineCode",{parentName:"p"},"fibjs")," 库的 shallowEqual 方法。假设 objA，objB 都是对象，提取关键代码的核心思想进行了改写："),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{className:"language-javascript"}),"function shallowEqual(objA, objB) {\n  if (objA === objB) {\n    return true;\n  }\n\n  const keysA = Object.keys(objA);\n  const keysB = Object.keys(objB);\n\n  if (keysA.length !== keysB.length) {\n    return false;\n  }\n\n  // 关键代码，只需关注 props 中每一个是否相等，无需深入判断\n  return keysA.every(key => \n    Object.hasOwnProperty.call(objB, keys) &&\n    objA[key] === objB[key];\n  )\n}\n")),Object(r.b)("p",null,"当 shallowEqual 为 true 的时候，shouldComponentUpdate 为 false，组件不会更新，这样便减少了某些组件的状态更新导致的一些不必要的 render 和 v-diff。"),Object(r.b)("h2",{id:"组件提纯"},"组件提纯"),Object(r.b)("p",null,"非纯代码虽然有害但不可或缺。大多数应用都需要全局状态、网络请求、本地存储等等。你能做的只是将非纯代码从纯代码中隔离出来，这一过程又成为 ",Object(r.b)("strong",{parentName:"p"},"提纯（purification）"),"。"),Object(r.b)("p",null,Object(r.b)("img",a({parentName:"p"},{src:"https://raw.githubusercontent.com/ThinkBucket/oss/master/pure.jpeg",alt:"组件提纯类比图"}))),Object(r.b)("p",null,"孤立的非纯代码有明确的副作用，或对全局状态的依赖。在隔离状态下，非纯代码对系统中其余部分的不可预测性影响会降低很多。"))}u.isMDXComponent=!0},147:function(e,n,t){"use strict";t.d(n,"a",(function(){return p})),t.d(n,"b",(function(){return i}));var r=t(0),a=t.n(r),o=a.a.createContext({}),l=function(e){var n=a.a.useContext(o),t=n;return e&&(t="function"==typeof e?e(n):Object.assign({},n,e)),t},p=function(e){var n=l(e.components);return a.a.createElement(o.Provider,{value:n},e.children)};var c="mdxType",b={inlineCode:"code",wrapper:function(e){var n=e.children;return a.a.createElement(a.a.Fragment,{},n)}},u=Object(r.forwardRef)((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,p=e.parentName,c=function(e,n){var t={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&-1===n.indexOf(r)&&(t[r]=e[r]);return t}(e,["components","mdxType","originalType","parentName"]),u=l(t),i=r,d=u[p+"."+i]||u[i]||b[i]||o;return t?a.a.createElement(d,Object.assign({},{ref:n},c,{components:t})):a.a.createElement(d,Object.assign({},{ref:n},c))}));function i(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,l=new Array(o);l[0]=u;var p={};for(var b in n)hasOwnProperty.call(n,b)&&(p[b]=n[b]);p.originalType=e,p[c]="string"==typeof e?e:r,l[1]=p;for(var i=2;i<o;i++)l[i]=t[i];return a.a.createElement.apply(null,l)}return a.a.createElement.apply(null,t)}u.displayName="MDXCreateElement"}}]);