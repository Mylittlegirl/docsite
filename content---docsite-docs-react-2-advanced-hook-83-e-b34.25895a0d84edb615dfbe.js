(window.webpackJsonp=window.webpackJsonp||[]).push([[101],{222:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"rightToc",(function(){return b})),n.d(t,"default",(function(){return p}));n(0);var a=n(390),c=n(391);function l(){return(l=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e}).apply(this,arguments)}function o(e,t){if(null==e)return{};var n,a,c=function(e,t){if(null==e)return{};var n,a,c={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(c[n]=e[n]);return c}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(c[n]=e[n])}return c}var i={title:"Hook",sidebar_label:"Hook"},b=[{value:"存在的意义",id:"存在的意义",children:[]},{value:"useState",id:"usestate",children:[{value:"一个例子",id:"一个例子",children:[]},{value:"声明状态",id:"声明状态",children:[]},{value:"读取状态",id:"读取状态",children:[]},{value:"更新状态",id:"更新状态",children:[]},{value:"多个状态",id:"多个状态",children:[]},{value:"怎么保证多个 useState 的相互独立",id:"怎么保证多个-usestate-的相互独立",children:[]}]},{value:"useEffect",id:"useeffect",children:[{value:"解剖图",id:"解剖图",children:[]},{value:"生命周期",id:"生命周期",children:[]},{value:"减少 useEffect 的执行",id:"减少-useeffect-的执行",children:[]},{value:"解绑一些副作用",id:"解绑一些副作用",children:[]},{value:"为什么每次更新的时候都要运行 useEffect",id:"为什么每次更新的时候都要运行-useeffect",children:[]}]},{value:"自带的 Hook",id:"自带的-hook",children:[]},{value:"自定义 Hook",id:"自定义-hook",children:[{value:"提取自定义 Hook",id:"提取自定义-hook",children:[]},{value:"使用自定义 Hook",id:"使用自定义-hook",children:[]}]},{value:"参考阅读",id:"参考阅读",children:[]}],r={rightToc:b},s="wrapper";function p(e){var t=e.components,n=o(e,["components"]);return Object(a.b)(s,l({},r,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。")),Object(a.b)("h2",{id:"存在的意义"},"存在的意义"),Object(a.b)("p",null,"Hook 的出现，就代表了它要解决一些 class 组件的缺陷或者不足，那么我们先来看看 class 组件有什么不足或者问题存在："),Object(a.b)("table",null,Object(a.b)("thead",{parentName:"table"},Object(a.b)("tr",{parentName:"thead"},Object(a.b)("th",l({parentName:"tr"},{align:null}),"问题"),Object(a.b)("th",l({parentName:"tr"},{align:null}),"解决方案"),Object(a.b)("th",l({parentName:"tr"},{align:null}),"缺点"),Object(a.b)("th",l({parentName:"tr"},{align:null}),"Hook"))),Object(a.b)("tbody",{parentName:"table"},Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null}),"1.",Object(a.b)("inlineCode",{parentName:"td"},"this")," 指向问题"),Object(a.b)("td",l({parentName:"tr"},{align:null}),"匿名函数"),Object(a.b)("td",l({parentName:"tr"},{align:null}),"每次都创建新的函数，子组件重复不必要渲染"),Object(a.b)("td",l({parentName:"tr"},{align:null}),"函数无 ",Object(a.b)("inlineCode",{parentName:"td"},"this")," 指向问题")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null})),Object(a.b)("td",l({parentName:"tr"},{align:null}),Object(a.b)("inlineCode",{parentName:"td"},"bind")),Object(a.b)("td",l({parentName:"tr"},{align:null}),"需要写很多跟逻辑、状态无关的代码"),Object(a.b)("td",l({parentName:"tr"},{align:null}))),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null}),"2.生命周期繁琐"),Object(a.b)("td",l({parentName:"tr"},{align:null}),"无"),Object(a.b)("td",l({parentName:"tr"},{align:null})),Object(a.b)("td",l({parentName:"tr"},{align:null}),Object(a.b)("inlineCode",{parentName:"td"},"useEffect")," 将三者合体简化")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null}),"3.生命周期内逻辑臃肿"),Object(a.b)("td",l({parentName:"tr"},{align:null}),"无"),Object(a.b)("td",l({parentName:"tr"},{align:null})),Object(a.b)("td",l({parentName:"tr"},{align:null}),"多个 ",Object(a.b)("inlineCode",{parentName:"td"},"useEffect")," 来细分逻辑")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null}),"4.逻辑难以复用"),Object(a.b)("td",l({parentName:"tr"},{align:null}),"通过继承解决"),Object(a.b)("td",l({parentName:"tr"},{align:null}),"不支持多继承"),Object(a.b)("td",l({parentName:"tr"},{align:null}),"自定义 Effect Hook")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null})),Object(a.b)("td",l({parentName:"tr"},{align:null}),"通过HOC解决"),Object(a.b)("td",l({parentName:"tr"},{align:null}),"会增加额外的组件嵌套，也会有一些性能影响"),Object(a.b)("td",l({parentName:"tr"},{align:null}))),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",l({parentName:"tr"},{align:null})),Object(a.b)("td",l({parentName:"tr"},{align:null}),"渲染属性"),Object(a.b)("td",l({parentName:"tr"},{align:null}),"同上、层级臃肿、性能影响"),Object(a.b)("td",l({parentName:"tr"},{align:null}))))),Object(a.b)("p",null,"当然，Hook 是一把双刃剑，用的好自己能够达到效果，用的不好反而会降低开发效率和质量，那么我们接下来看看如用更好地使用 Hook 。"),Object(a.b)("h2",{id:"usestate"},"useState"),Object(a.b)("h3",{id:"一个例子"},"一个例子"),Object(a.b)("p",null,"看一个例子，我们分解来看到底 state hook 做了什么："),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-jsx"}),"import { useState } from 'react';\n\nfunction Example() {\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n    </div>\n  );\n}\n")),Object(a.b)("h3",{id:"声明状态"},"声明状态"),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-jsx"}),"import { useState } from 'react';\n\nfunction Example() {\n  const [count, setCount] = useState(0);\n}\n")),Object(a.b)("p",null,Object(a.b)("inlineCode",{parentName:"p"},"useState")," 是 React 自带的一个 Hook 函数，它的作用就是用来声明状态变量。 ",Object(a.b)("inlineCode",{parentName:"p"},"useState")," 这个函数接收的参数是我们的状态初始值（initial state），它返回了一个数组，这个数组的第 ",Object(a.b)("inlineCode",{parentName:"p"},"[0]")," 项是当前当前的",Object(a.b)("strong",{parentName:"p"},"状态值"),"，第 ",Object(a.b)("inlineCode",{parentName:"p"},"[1]")," 项是可以改变状态值的",Object(a.b)("strong",{parentName:"p"},"方法函数"),"。"),Object(a.b)("p",null,"所以我们做的事情其实就是，声明了一个状态变量 ",Object(a.b)("inlineCode",{parentName:"p"},"count")," ，把它的初始值设为 0，同时提供了一个可以更改 ",Object(a.b)("inlineCode",{parentName:"p"},"count")," 的函数 ",Object(a.b)("inlineCode",{parentName:"p"},"setCount")," 。"),Object(a.b)("h3",{id:"读取状态"},"读取状态"),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-jsx"}),"<p>You clicked {count} times</p>\n")),Object(a.b)("p",null,"很简单，因为我们的状态 ",Object(a.b)("inlineCode",{parentName:"p"},"count")," 就是一个单纯的变量而已，我们再也不需要写成",Object(a.b)("inlineCode",{parentName:"p"},"{this.state.count}"),"这样了。"),Object(a.b)("h3",{id:"更新状态"},"更新状态"),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-jsx"}),"<button onClick={() => setCount(count + 1)}>\n  Click me\n</button>\n")),Object(a.b)("p",null,"当用户点击按钮时，我们调用 ",Object(a.b)("inlineCode",{parentName:"p"},"setCount")," 函数，这个函数接收的参数是修改过的新状态值。接下来的事情就交给 React 了，React 将会重新渲染我们的 ",Object(a.b)("inlineCode",{parentName:"p"},"Example")," 组件，并且使用的是更新后的新的状态，即 ",Object(a.b)("inlineCode",{parentName:"p"},"count=1")," 。这里我们要停下来思考一下， ",Object(a.b)("inlineCode",{parentName:"p"},"Example")," 本质上也是一个普通的函数，为什么它可以记住之前的状态？"),Object(a.b)("h3",{id:"多个状态"},"多个状态"),Object(a.b)("p",null,"首先，useState是可以多次调用的，所以我们完全可以这样写："),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-js"}),"function ExampleWithManyStates() {\n  const [age, setAge] = useState(42);\n  const [fruit, setFruit] = useState('banana');\n  const [todos, setTodos] = useState([{ text: 'Learn Hook' }]);\n}\n")),Object(a.b)("p",null,"其次， ",Object(a.b)("inlineCode",{parentName:"p"},"useState")," 接收的初始值没有规定一定要是 ",Object(a.b)("inlineCode",{parentName:"p"},"string/number/boolean")," 这种简单数据类型，它完全",Object(a.b)("strong",{parentName:"p"},"可以接收对象或者数组作为参数"),"。最后，React也给我们提供了一个 ",Object(a.b)("inlineCode",{parentName:"p"},"useReducer")," 的 hook ，如果你更喜欢 Redux 式的状态管理方案的话。"),Object(a.b)(c.a,{type:"warning",mdxType:"Hint"},"之前我们的 `this.setState` 做的是**合并状态**后返回一个新状态，而 `useState` 是直接**替换**老状态后返回新状态。"),Object(a.b)("p",null,"从 ",Object(a.b)("inlineCode",{parentName:"p"},"ExampleWithManyStates")," 函数我们可以看到， ",Object(a.b)("inlineCode",{parentName:"p"},"useState")," 无论调用多少次，相互之间是独立的。这一点至关重要。为什么这么说呢？"),Object(a.b)("p",null,"其实我们看 Hook 的“形态”，有点类似之前被官方否定掉的 Mixins 这种方案，都是提供一种“插拔式的功能注入”的能力。而 Mixins 之所以被否定，是因为",Object(a.b)("strong",{parentName:"p"},"Mixins 机制是让多个 Mixins 共享一个对象的数据空间"),"，这样就很难确保不同 Mixins 依赖的状态不发生冲突。"),Object(a.b)(c.a,{type:"tip",mdxType:"Hint"},"每一个 hook 都是相互独立的，**不同组件调用同一个hook也能保证各自状态的独立性。**这就是两者的本质区别了。"),Object(a.b)("h3",{id:"怎么保证多个-usestate-的相互独立"},"怎么保证多个 useState 的相互独立"),Object(a.b)("p",null,"还是看上面给出的 ",Object(a.b)("inlineCode",{parentName:"p"},"ExampleWithManyStates")," 例子，我们调用了三次",Object(a.b)("inlineCode",{parentName:"p"}," useState")," ，每次我们传的参数只是一个值（如42，'banana'），我们根本没有告诉 React 这些值对应的 key 是哪个，那 React是怎么保证这三个 ",Object(a.b)("inlineCode",{parentName:"p"},"useState")," 找到它对应的 state 呢？"),Object(a.b)(c.a,{type:"tip",mdxType:"Hint"},"React是根据 `useState` 出现的顺序来定的。"),Object(a.b)("p",null,"我们具体来看一下："),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-js"}),"  //第一次渲染\n  useState(42);  //将age初始化为42\n  useState('banana');  //将fruit初始化为banana\n  useState([{ text: 'Learn Hook' }]); //...\n\n  //第二次渲染\n  useState(42);  //读取状态变量age的值（这时候传的参数42直接被忽略）\n  useState('banana');  //读取状态变量fruit的值（这时候传的参数banana直接被忽略）\n  useState([{ text: 'Learn Hook' }]); //...\n")),Object(a.b)("p",null,"假如我们改一下代码："),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-js"}),"let showFruit = true;\nfunction ExampleWithManyStates() {\n  const [age, setAge] = useState(42);\n  \n  if(showFruit) {\n    const [fruit, setFruit] = useState('banana');\n    showFruit = false;\n  }\n\n  const [todos, setTodos] = useState([{ text: 'Learn Hook' }]);\n}\n")),Object(a.b)("p",null,"这样一来："),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-js"}),"//第一次渲染\nuseState(42);  //将age初始化为42\nuseState('banana');  //将fruit初始化为banana\nuseState([{ text: 'Learn Hook' }]); //...\n\n//第二次渲染\nuseState(42);  //读取状态变量age的值（这时候传的参数42直接被忽略）\n// useState('banana');  \nuseState([{ text: 'Learn Hook' }]); //读取到的却是状态变量fruit的值，导致报错\n")),Object(a.b)(c.a,{type:"must",mdxType:"Hint"},"React 规定我们必须把 hook 写在函数的最外层，不能写在 `ifelse` 等条件语句当中，来确保 hook 的执行顺序一致。"),Object(a.b)("h2",{id:"useeffect"},"useEffect"),Object(a.b)("h3",{id:"解剖图"},"解剖图"),Object(a.b)("img",{style:{border:"1px solid #eee"},src:"https://cosmos-x.oss-cn-hangzhou.aliyuncs.com/hook-structure.png"}),Object(a.b)("h3",{id:"生命周期"},"生命周期"),Object(a.b)("p",null,Object(a.b)("inlineCode",{parentName:"p"},"useState")," 只是让函数组件具有使用 state 的能力，那我们要解决 class 组件存在的问题，先来解决生命周期臃肿的问题。假设有这样一个需求，组件在状态更新的时候改变 ",Object(a.b)("inlineCode",{parentName:"p"},"document.title"),"，在以前我们会这样写代码："),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-jsx"}),"class Example extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      count: 0\n    };\n  }\n\n  componentDidMount() {\n    document.title = `You clicked ${this.state.count} times`;\n  }\n\n  componentDidUpdate() {\n    document.title = `You clicked ${this.state.count} times`;\n  }\n\n  render() {\n    return (\n      <div>\n        <p>You clicked {this.state.count} times</p>\n        <button onClick={() => this.setState({ count: this.state.count + 1 })}>\n          Click me\n        </button>\n      </div>\n    );\n  }\n}\n")),Object(a.b)("p",null,"我们写的有状态组件，通常会产生很多的副作用（Side Effect），比如发起 ajax 请求获取数据，添加一些监听的注册和取消注册，手动修改 DOM 等等。",Object(a.b)("strong",{parentName:"p"},"我们之前都把这些副作用的函数写在生命周期函数钩子里"),"。现在使用 hook 改写以上代码："),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-jsx"}),"import { useState, useEffect } from 'react';\n\nfunction Example() {\n  const [count, setCount] = useState(0);\n\n  // 类似于componentDidMount 和 componentDidUpdate:\n  useEffect(() => {\n    // 更新文档的标题\n    document.title = `You clicked ${count} times`;\n  });\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n    </div>\n  );\n}\n")),Object(a.b)(c.a,{type:"tip",mdxType:"Hint"},"可以将 `useEffect` 看成是 `componentDidMount` ， `componentDidUpdate` 和 `componentWillUnmount` 三者的合体。"),Object(a.b)(c.a,{type:"warning",mdxType:"Hint"},"如果 `useEffect` 没有返回函数，那么 `componentWillUnmount` 的时候是不会执行 `useEffect`。"),Object(a.b)("p",null,"我们再梳理一遍下面代码的逻辑："),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-jsx"}),"function Example() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    document.title = `You clicked ${count} times`;\n  });\n}\n")),Object(a.b)("p",null,"首先，我们声明了一个状态变量 ",Object(a.b)("inlineCode",{parentName:"p"},"count")," ，将它的初始值设为 0。然后我们告诉 React，我们的这个组件有一个副作用。我们给 ",Object(a.b)("inlineCode",{parentName:"p"},"useEffect")," hook 传了一个匿名函数，这个匿名函数就是我们的副作用。"),Object(a.b)("p",null,"在这个例子里，我们的副作用是调用 Browser API 来修改文档标题。当 React 要渲染我们的组件时，它会先记住我们用到的副作用。等 React 更新了 DOM 之后，它再依次执行我们定义的副作用函数。"),Object(a.b)(c.a,{type:"warning",mdxType:"Hint"},"`useEffect` 中定义的副作用函数的执行不会阻碍浏览器更新视图，也就是说这些函数是**异步**执行的，而之前的 `componentDidMount` 或 `componentDidUpdate` 中的代码则是同步执行的。"),Object(a.b)("p",null,"这种安排对大多数副作用说都是合理的，但有的情况除外，比如我们有时候需要先根据 DOM 计算出某个元素的尺寸再重新渲染，这时候我们希望这次重新渲染是同步发生的，也就是说它会在浏览器真的去绘制这个页面前发生。"),Object(a.b)("h3",{id:"减少-useeffect-的执行"},"减少 useEffect 的执行"),Object(a.b)("p",null,"每次重新渲染都要执行一遍这些副作用函数，显然是不经济的。怎么跳过一些不必要的计算呢？我们只需要给 ",Object(a.b)("inlineCode",{parentName:"p"},"useEffect")," 传第二个参数即可。用第二个参数来告诉 React 只有当这个参数的值发生改变时，才执行我们传的副作用函数（第一个参数）："),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-jsx"}),"useEffect(() => {\n  document.title = `You clicked ${count} times`;\n}, [count]); // 只有当count的值发生变化时，才会重新执行`document.title`这一句\n")),Object(a.b)("p",null,"上面这个示例中，我们传入 ",Object(a.b)("inlineCode",{parentName:"p"},"[count]")," 作为第二个参数。这个参数是什么作用呢？如果 count 的值是 5，而且我们的组件重渲染的时候 ",Object(a.b)("inlineCode",{parentName:"p"},"count")," 还是等于 5，React 将对前一次渲染的 ","[5]"," 和后一次渲染的 ","[5]"," 进行比较。因为数组中的所有元素都是相等的(",Object(a.b)("inlineCode",{parentName:"p"},"5 === 5"),")，React 会跳过这个 effect，这就实现了性能的优化。"),Object(a.b)(c.a,{type:"tip",mdxType:"Hint"},"如果数组中有多个元素，即使只有一个元素发生变化，React 也会执行 `useEffect` 。"),Object(a.b)("p",null,Object(a.b)("inlineCode",{parentName:"p"},"useEffect")," 的第二个参数，有三种情况："),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"什么都不传，组件每次渲染和更新都会调用，相当于 ",Object(a.b)("inlineCode",{parentName:"li"},"componentDidMount"),", ",Object(a.b)("inlineCode",{parentName:"li"},"componentDidUpdate")," 和 ",Object(a.b)("inlineCode",{parentName:"li"},"componentWillUnmount")),Object(a.b)("li",{parentName:"ul"},"传入一个空数组 ",Object(a.b)("inlineCode",{parentName:"li"},"[]")," , 只会在首次渲染时调用一次，相当于 ",Object(a.b)("inlineCode",{parentName:"li"},"componentDidMount")," 和 ",Object(a.b)("inlineCode",{parentName:"li"},"componentWillUnmount")),Object(a.b)("li",{parentName:"ul"},"传入一个数组，其中包括变量，只有这些变量变动时， ",Object(a.b)("inlineCode",{parentName:"li"},"useEffect")," 才会执行")),Object(a.b)(c.a,{type:"warning",mdxType:"Hint"},"当我们第二个参数传一个空数组 `[]` 时，这种用法可能带来 Bug，少用。"),Object(a.b)("p",null,"第二个参数，可以传递 ",Object(a.b)("inlineCode",{parentName:"p"},"props")," ，例如："),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-jsx"}),"useEffect(() => {\n  console.log(`You clicked times`)\n  document.title = `You clicked times`;\n}, [props.time]);\n")),Object(a.b)("p",null,Object(a.b)("inlineCode",{parentName:"p"},"time")," 的更新也会执行 ",Object(a.b)("inlineCode",{parentName:"p"},"useEffect"),"，另外可以启用 ",Object(a.b)("a",l({parentName:"p"},{href:"https://www.npmjs.com/package/eslint-plugin-react-hooks"}),"eslint-plugin-react-hooks")," 中的 ",Object(a.b)("a",l({parentName:"p"},{href:"https://github.com/facebook/react/issues/14920"}),"exhaustive-deps")," 规则，这样 ",Object(a.b)("inlineCode",{parentName:"p"},"useEffect")," 里面若有依赖的变量，比如 ",Object(a.b)("inlineCode",{parentName:"p"},"count"),"，没在 deps 数组里面声明则会出现以下警告并给出修复建议，空数组也是会提示的："),Object(a.b)("img",{src:"https://cosmos-x.oss-cn-hangzhou.aliyuncs.com/wlmFn7.png"}),Object(a.b)("p",null,"另外，由于前文所说 Hook 可以反复多次使用，相互独立。所以相对合理的做法是："),Object(a.b)(c.a,{type:"better",mdxType:"Hint"},"给每一个副作用一个单独的 `useEffect` 钩子。这样一来，这些副作用不再一股脑堆在生命周期钩子里，代码变得更加清晰。一些不必要的 `useEffect` 函数也可以避免。"),Object(a.b)("h3",{id:"解绑一些副作用"},"解绑一些副作用"),Object(a.b)("p",null,"这种场景很常见，当我们在 ",Object(a.b)("inlineCode",{parentName:"p"},"componentDidMount")," 里添加了一个注册，我们得马上在 ",Object(a.b)("inlineCode",{parentName:"p"},"componentWillUnmount")," 中，也就是",Object(a.b)("strong",{parentName:"p"},"组件被注销之前"),"清除掉我们添加的注册，否则",Object(a.b)("strong",{parentName:"p"},"内存泄漏"),"的问题就出现了。"),Object(a.b)("p",null,"怎么清除呢？看下面的例子："),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-jsx"}),"import { useState, useEffect } from 'react';\n\nfunction FriendStatus(props) {\n  const [isOnline, setIsOnline] = useState(null);\n\n  function handleStatusChange(status) {\n    setIsOnline(status.isOnline);\n  }\n\n  useEffect(() => {\n    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);\n    // 一定注意下这个顺序：告诉 React 在下次重新渲染组件之后，同时是下次调用ChatAPI.subscribeToFriendStatus 之前执行 cleanup\n    return function cleanup() {\n      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);\n    };\n  });\n\n  if (isOnline === null) {\n    return 'Loading...';\n  }\n  return isOnline ? 'Online' : 'Offline';\n}\n")),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"为什么要在 effect 中返回一个函数？")," 这是 effect 可选的清除机制。每个 effect 都可以返回一个清除函数。如此可以将添加和移除订阅这些紧密性比较强的逻辑放在一起。它们都属于 effect 的一部分。"),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"React 何时清除 effect？")," ",Object(a.b)("inlineCode",{parentName:"p"},"componentDidUpdate")," + ",Object(a.b)("inlineCode",{parentName:"p"},"componentWillUnmount"),"。首次不执行，React 会在执行当前 effect 之前对上一个 effect 进行清除，这也解释了为什么每次更新的时候都要运行 ",Object(a.b)("inlineCode",{parentName:"p"},"useEffect")," 。"),Object(a.b)(c.a,{type:"tip",mdxType:"Hint"},"并不是必须为 effect 中返回的函数命名。这里我们将其命名为 `cleanup` 是为了表明此函数的目的，但其实也可以返回一个箭头函数或者给起一个别的名字。"),Object(a.b)(c.a,{type:"tip",mdxType:"Hint"},"`useEffect` 可以在组件渲染后实现各种不同的副作用。有些副作用可能需要清除，则需要返回一个函数。有些 effect 可能不必清除，所以不需要返回函数。"),Object(a.b)(c.a,{type:"warning",mdxType:"Hint"},"这种解绑的模式跟 `componentWillUnmount` 不一样。 `componentWillUnmount` 只会在组件被销毁前执行一次而已，而 `useEffect` ，每次组件渲染后都会执行一遍 `useEffect` 里的函数，包括返回的 `cleanup` 函数也会重新执行一遍。"),Object(a.b)("h3",{id:"为什么每次更新的时候都要运行-useeffect"},"为什么每次更新的时候都要运行 useEffect"),Object(a.b)("p",null,"我们先看以前的模式："),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-jsx"}),"componentDidMount() {\n  ChatAPI.subscribeToFriendStatus(\n    this.props.friend.id,\n    this.handleStatusChange\n  );\n}\n\ncomponentWillUnmount() {\n  ChatAPI.unsubscribeFromFriendStatus(\n    this.props.friend.id,\n    this.handleStatusChange\n  );\n}\n")),Object(a.b)("p",null,"我们在 ",Object(a.b)("inlineCode",{parentName:"p"},"componentDidMount")," 注册，再在 ",Object(a.b)("inlineCode",{parentName:"p"},"componentWillUnmount")," 清除注册。但假如这时候 ",Object(a.b)("inlineCode",{parentName:"p"},"props.friend.id")," 变了怎么办？我们不得不再添加一个 ",Object(a.b)("inlineCode",{parentName:"p"},"componentDidUpdate")," 来处理这种情况："),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-jsx"}),"componentDidUpdate(prevProps) {\n  // 先把上一个friend.id解绑\n  ChatAPI.unsubscribeFromFriendStatus(\n    prevProps.friend.id,\n    this.handleStatusChange\n  );\n  // 再重新注册新但friend.id\n  ChatAPI.subscribeToFriendStatus(\n    this.props.friend.id,\n    this.handleStatusChange\n  );\n}\n")),Object(a.b)("p",null,"看到了吗？很繁琐，而我们但 ",Object(a.b)("inlineCode",{parentName:"p"},"useEffect")," 则没这个问题，因为它在每次组件更新后都会重新执行一遍。所以代码的执行顺序是这样的："),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-text"}),"1.页面首次渲染\n2.替friend.id=1的朋友注册\n\n3.突然friend.id变成了2\n4.页面重新渲染\n5.清除friend.id=1的绑定\n6.替friend.id=2的朋友注册\n...\n")),Object(a.b)("h2",{id:"自带的-hook"},"自带的 Hook"),Object(a.b)("p",null,"除了上文重点介绍的 ",Object(a.b)("inlineCode",{parentName:"p"},"useState")," 和 ",Object(a.b)("inlineCode",{parentName:"p"},"useEffect")," ，React 还给我们提供来很多有用的 Hook ："),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"useContext"),Object(a.b)("li",{parentName:"ul"},"useReducer"),Object(a.b)("li",{parentName:"ul"},"useCallback"),Object(a.b)("li",{parentName:"ul"},"useMemo"),Object(a.b)("li",{parentName:"ul"},"useRef"),Object(a.b)("li",{parentName:"ul"},"useImperativeMethods"),Object(a.b)("li",{parentName:"ul"},"useLayoutEffect"),Object(a.b)("li",{parentName:"ul"},"useDebugValue")),Object(a.b)("p",null,"更多查阅",Object(a.b)("a",l({parentName:"p"},{href:"https://zh-hans.reactjs.org/docs/hooks-reference.html"}),"官方介绍")),Object(a.b)("h2",{id:"自定义-hook"},"自定义 Hook"),Object(a.b)("p",null,"为什么要自己去写一个 Effect Hooks ? 这样我们才能把可以复用的逻辑抽离出来，变成一个个可以随意插拔的“插销”，哪个组件要用来，我就插进哪个组件里，下面看一个官网的例子。"),Object(a.b)("p",null,"假如这个时候我们又有一个朋友列表 ",Object(a.b)("inlineCode",{parentName:"p"},"FriendListItem")," 也需要显示是否在线的信息，这时就需要用到 ",Object(a.b)("inlineCode",{parentName:"p"},"FriendStatus")," 中的这段逻辑："),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-jsx"}),"const [isOnline, setIsOnline] = useState(null);\n\nuseEffect(() => {\n  function handleStatusChange(status) {\n    setIsOnline(status.isOnline);\n  }\n\n  ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);\n  return () => {\n    ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);\n  };\n});\n")),Object(a.b)("p",null,"在 React 中有两种流行的方式来共享组件之间的状态逻辑: ",Object(a.b)("strong",{parentName:"p"},"Render-Props")," 和",Object(a.b)("strong",{parentName:"p"},"高阶组件"),"，现在让我们来看看 Hook 是如何在让你不增加组件的情况下解决相同问题的。"),Object(a.b)("h3",{id:"提取自定义-hook"},"提取自定义 Hook"),Object(a.b)("p",null,"当我们想在两个函数之间共享逻辑时，我们会把它提取到第三个函数中。而组件和 Hook 都是函数，所以也同样适用这种方式。"),Object(a.b)("p",null,"我们将公共的部门提取出来，新建一个 ",Object(a.b)("inlineCode",{parentName:"p"},"useFriendStatus")," 的 Hook 专门用来判断某个id 是否在线。"),Object(a.b)(c.a,{type:"must",mdxType:"Hint"},"自定义 Hook 必须以 “use” 开头，不遵循的话，由于无法判断某个函数是否包含对其内部 Hook 的调用，React 将无法自动检查你的 Hook 是否违反了 [Hook 的规则](https://zh-hans.reactjs.org/docs/hooks-rules.html)。"),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-jsx"}),"import { useState, useEffect } from 'react';\n\nfunction useFriendStatus(friendID) {\n  const [isOnline, setIsOnline] = useState(null);\n\n  function handleStatusChange(status) {\n    setIsOnline(status.isOnline);\n  }\n\n  useEffect(() => {\n    ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);\n    return () => {\n      ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);\n    };\n  });\n\n  return isOnline;\n}\n")),Object(a.b)("p",null," React 组件不同的是，自定义 Hook 不需要具有特殊的标识。我们可以自由的决定它的参数是什么，以及它应该返回什么（如果需要的话）。换句话说，它就像一个正常的函数，函数内部可以调用其他的 Hook。"),Object(a.b)("h3",{id:"使用自定义-hook"},"使用自定义 Hook"),Object(a.b)("p",null,"我们一开始的目标是在 ",Object(a.b)("inlineCode",{parentName:"p"},"FriendStatus")," 和 ",Object(a.b)("inlineCode",{parentName:"p"},"FriendListItem")," 组件中去除重复的逻辑，即：这两个组件都想知道好友是否在线。"),Object(a.b)("p",null,"现在我们已经把这个逻辑提取到 ",Object(a.b)("inlineCode",{parentName:"p"},"useFriendStatus")," 的自定义 Hook 中，然后就可以使用它了："),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-jsx"}),"function FriendStatus(props) {\n  const isOnline = useFriendStatus(props.friend.id);\n\n  if (isOnline === null) {\n    return 'Loading...';\n  }\n  return isOnline ? 'Online' : 'Offline';\n}\n")),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-jsx"}),"function FriendListItem(props) {\n  const isOnline = useFriendStatus(props.friend.id);\n\n  return (\n    <li style={{ color: isOnline ? 'green' : 'black' }}>\n      {props.friend.name}\n    </li>\n  );\n}\n")),Object(a.b)("p",null,"仔细观察，你会发现我们没有对其行为做任何的改变，我们只是将两个函数之间一些共同的代码提取到单独的函数中。",Object(a.b)("strong",{parentName:"p"},"自定义 Hook 是一种自然遵循 Hook 设计的约定，而并不是 React 的特性"),"。"),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"在两个组件中使用相同的 Hook 会共享 state 吗？"),"不会。自定义 Hook 是一种重用状态逻辑的机制(例如设置为订阅并存储当前值)，所以每次使用自定义 Hook 时，其中的所有 state 和副作用都是完全隔离的。"),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"自定义 Hook 如何获取独立的 state？"),"每次调用 Hook，它都会获取独立的 state。由于我们直接调用了 ",Object(a.b)("inlineCode",{parentName:"p"},"useFriendStatus")," ，从 React 的角度来看，我们的组件只是调用了 ",Object(a.b)("inlineCode",{parentName:"p"},"useState")," 和 ",Object(a.b)("inlineCode",{parentName:"p"},"useEffect")," 。 正如我们在之前了解到的一样，我们可以在一个组件中多次调用 ",Object(a.b)("inlineCode",{parentName:"p"},"useState")," 和 ",Object(a.b)("inlineCode",{parentName:"p"},"useEffect")," ，它们是完全独立的。"),Object(a.b)("p",null,"通过以上例子会发现自定义 Hook 的基石还是 ",Object(a.b)("inlineCode",{parentName:"p"},"useState")," 和 ",Object(a.b)("inlineCode",{parentName:"p"},"useEffect")," 。更多内容请",Object(a.b)("a",l({parentName:"p"},{href:"https://zh-hans.reactjs.org/docs/hooks-custom.html#tip-pass-information-between-hooks"}),"阅读官方"),"。"),Object(a.b)("h2",{id:"参考阅读"},"参考阅读"),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},Object(a.b)("a",l({parentName:"li"},{href:"https://zh-hans.reactjs.org/docs/hooks-intro.html"}),"React Hook 官方文档")),Object(a.b)("li",{parentName:"ol"},Object(a.b)("a",l({parentName:"li"},{href:"https://juejin.im/post/5d985deae51d4577f9285c2f"}),"呕心沥血，一文看懂 react hooks，作者：landluck")),Object(a.b)("li",{parentName:"ol"},Object(a.b)("a",l({parentName:"li"},{href:"https://segmentfault.com/a/1190000016950339"}),"30分钟精通React今年最劲爆的新特性—React Hooks，作者：zach5078")),Object(a.b)("li",{parentName:"ol"},Object(a.b)("a",l({parentName:"li"},{href:"https://juejin.im/post/5d594ea5518825041301bbcb#heading-52"}),"2019年了，整理了N个实用案例帮你快速迁移到React Hooks(收藏慢慢看系列)，作者：",Object(a.b)("em",{parentName:"a"},"sx"))),Object(a.b)("li",{parentName:"ol"},Object(a.b)("a",l({parentName:"li"},{href:"https://juejin.im/post/5c9827745188250ff85afe50"}),"精读《useEffect 完全指南》，作者：黄子毅")),Object(a.b)("li",{parentName:"ol"},Object(a.b)("a",l({parentName:"li"},{href:"https://react.jokcy.me/book/hooks/hooks-use-effect.html"}),"useEffect 源码解析"))))}p.isMDXComponent=!0},391:function(e,t,n){"use strict";var a=n(0),c=n.n(a),l=n(393),o=n.n(l),i=(n(392),{better:{name:"推荐",color:"#50c610",icon:c.a.createElement("svg",{preserveAspectRatio:"xMidYMid meet",height:"1em",width:"1em",fill:"none",xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",strokeWidth:"2",strokeLinecap:"round",strokeLinejoin:"round",stroke:"currentColor",className:"custom-hint__icon",style:{color:"#50c610"}},c.a.createElement("g",null,c.a.createElement("path",{d:"M22 11.07V12a10 10 0 1 1-5.93-9.14"}),c.a.createElement("polyline",{points:"23 3 12 14 9 11"})))},must:{name:"强制",color:"#ff4642",icon:c.a.createElement("svg",{preserveAspectRatio:"xMidYMid meet",height:"1em",width:"1em",fill:"#ff4642",xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 1024 1024",stroke:"none",className:"custom-hint__icon"},c.a.createElement("g",null,c.a.createElement("path",{d:"M512 992c-262.4 0-480-217.6-480-480 0-262.4 217.6-480 480-480s480 217.6 480 480C992 774.4 774.4 992 512 992zM512 108.8C288 108.8 108.8 288 108.8 512c0 224 179.2 403.2 403.2 403.2s403.2-179.2 403.2-403.2C915.2 288 736 108.8 512 108.8zM697.6 684.8l-12.8 12.8c-6.4 6.4-19.2 6.4-25.6 0L512 550.4l-140.8 140.8c-6.4 6.4-19.2 6.4-25.6 0l-12.8-12.8c-6.4-6.4-6.4-19.2 0-25.6L473.6 512 326.4 371.2C320 358.4 320 345.6 326.4 339.2l12.8-12.8C345.6 320 358.4 320 371.2 326.4L512 473.6l140.8-140.8c6.4-6.4 19.2-6.4 25.6 0l12.8 12.8c6.4 6.4 6.4 19.2 0 25.6L550.4 512l140.8 140.8C704 665.6 704 678.4 697.6 684.8z"})))},tip:{name:"提示",color:"#3884ff",icon:c.a.createElement("svg",{preserveAspectRatio:"xMidYMid meet",height:"1em",width:"1em",fill:"currentColor",xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",stroke:"none",className:"custom-hint__icon",style:{color:"#3884ff"}},c.a.createElement("g",null,c.a.createElement("path",{d:"M12.2 8.98c.06-.01.12-.03.18-.06.06-.02.12-.05.18-.09l.15-.12c.18-.19.29-.45.29-.71 0-.06-.01-.13-.02-.19a.603.603 0 0 0-.06-.19.757.757 0 0 0-.09-.18c-.03-.05-.08-.1-.12-.15-.28-.27-.72-.37-1.09-.21-.13.05-.23.12-.33.21-.04.05-.09.1-.12.15-.04.06-.07.12-.09.18-.03.06-.05.12-.06.19-.01.06-.02.13-.02.19 0 .26.11.52.29.71.1.09.2.16.33.21.12.05.25.08.38.08.06 0 .13-.01.2-.02M13 16v-4a1 1 0 1 0-2 0v4a1 1 0 1 0 2 0M12 3c-4.962 0-9 4.038-9 9 0 4.963 4.038 9 9 9 4.963 0 9-4.037 9-9 0-4.962-4.037-9-9-9m0 20C5.935 23 1 18.065 1 12S5.935 1 12 1c6.066 0 11 4.935 11 11s-4.934 11-11 11",fillRule:"evenodd"})))},warning:{name:"注意",color:"#fdbe12",icon:c.a.createElement("svg",{preserveAspectRatio:"xMidYMid meet",height:"1em",width:"1em",fill:"none",xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",strokeWidth:"2",strokeLinecap:"round",strokeLinejoin:"round",stroke:"currentColor",className:"custom-hint__icon",style:{color:"#fdbe12"}},c.a.createElement("g",null,c.a.createElement("circle",{cx:"12",cy:"12",r:"10"}),c.a.createElement("line",{x1:"12",y1:"8",x2:"12",y2:"12"}),c.a.createElement("line",{x1:"12",y1:"16",x2:"12",y2:"16"})))}});t.a=function(e){var t=e.type,n=e.children;return c.a.createElement("div",{className:"custom-hint",style:{borderLeft:"4px solid ".concat(i[t].color)}},c.a.createElement("div",{style:{float:"left"}},i[t].icon),c.a.createElement("div",{dangerouslySetInnerHTML:{__html:o()("<strong>".concat(i[t].name,"</strong>：").concat(n))}}))}},392:function(e,t,n){}}]);