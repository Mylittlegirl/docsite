(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{122:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return b})),t.d(n,"rightToc",(function(){return c})),t.d(n,"default",(function(){return u}));t(0);var a=t(396);function r(){return(r=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e}).apply(this,arguments)}function l(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var b={title:"执行上下文",sidebar_label:"执行上下文"},c=[{value:"Activation / Variable Object AO/VO",id:"activation--variable-object-aovo",children:[]},{value:"变量名提升(Hoisting)",id:"变量名提升hoisting",children:[]}],i={rightToc:c},o="wrapper";function u(e){var n=e.components,t=l(e,["components"]);return Object(a.b)(o,r({},i,t,{components:n,mdxType:"MDXLayout"}),Object(a.b)("p",null,"这是混淆经常出现的地方，“执行上下文（Execution Context）”更多地涉及作用域而不是如前所述的上下文（Context），可以理解为当前代码的执行环境。这是一个不幸的命名约定，但它是ECMAScript规范定义的术语。"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("strong",{parentName:"li"},"上下文"),"：方法属于哪一个对象，即this指代那个对象，即",Object(a.b)("strong",{parentName:"li"},"上下文是基于对象的"),"。"),Object(a.b)("li",{parentName:"ul"},Object(a.b)("strong",{parentName:"li"},"执行上下文"),"：除了this指向还包括VO和作用域链，更偏向于作用域的描述。比如全局EC：")),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"windowEC = {\n   VO: Window,\n   scopeChain: {},\n   this: Window\n}\n")),Object(a.b)("p",null,"JS是单线程语言，意味着一次只能执行一个任务。当JS编译器最初执行代码时，它首先默认进入全局执行上下文。以后每次调用一个函数都会导致创建一个新的执行上下文。"),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"每进入一个不同的运行环境都会创建一个相应的执行上下文"),"，那么在一段JS程序中一般都会创建多个执行上下文，JS引擎会以",Object(a.b)("strong",{parentName:"p"},"栈"),"的方式对这些执行上下文进行处理，形成函数调用栈（call stack），栈底永远是全局执行上下文，栈顶则永远是当前执行上下文。"),Object(a.b)("p",null,"EC特点："),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"单线程"),Object(a.b)("li",{parentName:"ul"},"同步执行，只有栈顶的上下文处于执行中，其他上下文需要等待"),Object(a.b)("li",{parentName:"ul"},"全局上下文只有唯一的一个，它在浏览器关闭时出栈"),Object(a.b)("li",{parentName:"ul"},"每次函数被调用，就会有个新的执行上下文为其创建，即使是调用的自身函数，也是如此。")),Object(a.b)("p",null,"两大阶段"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("strong",{parentName:"li"},"创建阶段")," ","[函数调用时，执行内部代码前]",":",Object(a.b)("ul",{parentName:"li"},Object(a.b)("li",{parentName:"ul"},"根据之前解析阶段的成果创建作用域链"),Object(a.b)("li",{parentName:"ul"},"创建 variables, functions 和 arguments"),Object(a.b)("li",{parentName:"ul"},'确定 "this" 的值'))),Object(a.b)("li",{parentName:"ul"},Object(a.b)("strong",{parentName:"li"},"激活 / 代码执行阶段"),":",Object(a.b)("ul",{parentName:"li"},Object(a.b)("li",{parentName:"ul"},"赋值"),Object(a.b)("li",{parentName:"ul"},"函数引用"),Object(a.b)("li",{parentName:"ul"},"解释(编译)执行代码")))),Object(a.b)("p",null,"可以将每个执行上下文在概念上表示为具有3个属性的对象："),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"executionContextObj = {\n   'scopeChain': { /* variableObject + all parent execution context's variableObject */ },\n   'variableObject': { /* function arguments / parameters, inner variable and function declarations */ },\n   'this': {}\n}\n")),Object(a.b)("h3",{id:"activation--variable-object-aovo"},"Activation / Variable Object ","[AO/VO]"),Object(a.b)("p",null,"创建阶段解释器通过扫描传入的参数或参数的函数，本地函数声明和局部变量声明来创建executionContextObj。此扫描的结果将成为executionContextObj中的variableObject。"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"查找调用函数的代码。"),Object(a.b)("li",{parentName:"ul"},"创建阶段，在之前函数内部代码之前，先创建执行上下文:",Object(a.b)("ul",{parentName:"li"},Object(a.b)("li",{parentName:"ul"},"初始化作用域链."),Object(a.b)("li",{parentName:"ul"},"创建变量对象VO:",Object(a.b)("ul",{parentName:"li"},Object(a.b)("li",{parentName:"ul"},"创建arguments对象，检查上下文，初始化参数名称和值并创建引用的复制。"),Object(a.b)("li",{parentName:"ul"},"扫描上下文的函数声明:",Object(a.b)("ul",{parentName:"li"},Object(a.b)("li",{parentName:"ul"},"为每一个函数，在variableObject上创建一个{函数名: 引用地址}."),Object(a.b)("li",{parentName:"ul"},"如果函数的名字已经存在，引用指针将被重写."))),Object(a.b)("li",{parentName:"ul"},"扫描上下文的变量声明:",Object(a.b)("ul",{parentName:"li"},Object(a.b)("li",{parentName:"ul"},"为每个变量声明，在variableObject上创建一个{ 变量名: undefined}"),Object(a.b)("li",{parentName:"ul"},"如果变量名已经在variableObject里，将不会进行任何操作并继续扫描."))),Object(a.b)("li",{parentName:"ul"},'确定上下文内部 "this" 的值.'))))),Object(a.b)("li",{parentName:"ul"},"激活 / 代码执行阶段:",Object(a.b)("ul",{parentName:"li"},Object(a.b)("li",{parentName:"ul"},"在当前上下文上运行/解释函数代码，并随着代码一行行执行指派变量的值")))),Object(a.b)("p",null,"示例:"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"function foo(i) {\n   var a = 'hello';\n   var b = function privateB() {};\n   function c() {}\n}\n\nfoo(22);\n")),Object(a.b)("p",null,"在调用 ",Object(a.b)("inlineCode",{parentName:"p"},"foo(22)")," 时，创建阶段如下所示:"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"fooExecutionContext = {\n   scopeChain: { ... },\n   variableObject: {\n       arguments: {\n           0: 22,\n           length: 1\n       },\n       i: 22,\n       c: pointer to function c()\n       a: undefined,\n       b: undefined\n   },\n   this: { ... }\n}\n")),Object(a.b)("p",null,"创建阶段处理定义属性的名称，而不是为它们赋值，但参数除外。创建阶段完成后，进入函数执行流程，激活/代码执行阶段在函数执行完毕后如下所示:"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"fooExecutionContext = {\n   scopeChain: { ... },\n   variableObject: {\n       arguments: {\n           0: 22,\n           length: 1\n       },\n       i: 22,\n       c: pointer to function c()\n       a: 'hello',\n       b: pointer to function privateB()\n   },\n   this: { ... }\n}\n")),Object(a.b)("h3",{id:"变量名提升hoisting"},"变量名提升(Hoisting)"),Object(a.b)("p",null,"掌握了关于解释器如何创建AO的新知识，很容易理解为什么会发生这种情况的细节。请以下代码："),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"​(function() {\n    console.log(typeof foo); // function pointer\n    console.log(typeof bar); // undefined\n    function foo() {\n       return 'hello';\n    }\n    var foo = 'hello';\n    var bar = function() {\n       return 'world';\n    };\n}());​\n")),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"Q: 为什么我们能在foo声明之前访问它？")),Object(a.b)("p",null,"A: 在函数内部代码执行之前会有一个创建阶段，foo那个时候就已经在VO里面被定义了。"),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"Q: Foo被声明了两次，为什么foo显示为函数而不是undefined或字符串？")),Object(a.b)("p",null,"A: 首先扫描函数声明比扫描变量声明早，其次扫描变量声明时如果发现VO中已经存在了则会跳过。"),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"Q: 为什么bar的值是undefined？")),Object(a.b)("p",null,"bar实际上是一个变量，但变量的值是函数，并且我们知道变量在创建阶段被创建但他们被初始化为undefined。"))}u.isMDXComponent=!0},396:function(e,n,t){"use strict";t.d(n,"a",(function(){return c})),t.d(n,"b",(function(){return p}));var a=t(0),r=t.n(a),l=r.a.createContext({}),b=function(e){var n=r.a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):Object.assign({},n,e)),t},c=function(e){var n=b(e.components);return r.a.createElement(l.Provider,{value:n},e.children)};var i="mdxType",o={inlineCode:"code",wrapper:function(e){var n=e.children;return r.a.createElement(r.a.Fragment,{},n)}},u=Object(a.forwardRef)((function(e,n){var t=e.components,a=e.mdxType,l=e.originalType,c=e.parentName,i=function(e,n){var t={};for(var a in e)Object.prototype.hasOwnProperty.call(e,a)&&-1===n.indexOf(a)&&(t[a]=e[a]);return t}(e,["components","mdxType","originalType","parentName"]),u=b(t),p=a,O=u[c+"."+p]||u[p]||o[p]||l;return t?r.a.createElement(O,Object.assign({},{ref:n},i,{components:t})):r.a.createElement(O,Object.assign({},{ref:n},i))}));function p(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var l=t.length,b=new Array(l);b[0]=u;var c={};for(var o in n)hasOwnProperty.call(n,o)&&(c[o]=n[o]);c.originalType=e,c[i]="string"==typeof e?e:a,b[1]=c;for(var p=2;p<l;p++)b[p]=t[p];return r.a.createElement.apply(null,b)}return r.a.createElement.apply(null,t)}u.displayName="MDXCreateElement"}}]);