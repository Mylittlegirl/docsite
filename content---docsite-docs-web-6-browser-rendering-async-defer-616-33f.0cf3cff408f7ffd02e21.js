(window.webpackJsonp=window.webpackJsonp||[]).push([[171],{360:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return p})),t.d(n,"rightToc",(function(){return o})),t.d(n,"default",(function(){return s}));t(0);var r=t(396);function a(){return(a=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r])}return e}).apply(this,arguments)}function c(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},c=Object.keys(e);for(r=0;r<c.length;r++)t=c[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var c=Object.getOwnPropertySymbols(e);for(r=0;r<c.length;r++)t=c[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var p={id:"async-defer",title:"async和defer",sidebar_label:"async和defer"},o=[],i={rightToc:o},l="wrapper";function s(e){var n=e.components,t=c(e,["components"]);return Object(r.b)(l,a({},i,t,{components:n,mdxType:"MDXLayout"}),Object(r.b)("p",null,Object(r.b)("img",a({parentName:"p"},{src:"https://cosmos-x.oss-cn-hangzhou.aliyuncs.com/OelrrE.png",alt:null}))),Object(r.b)("p",null,"其中蓝色线代表JS加载；红色线代表JS执行；绿色线代表 HTML 解析。"),Object(r.b)("p",null,"defer: 延迟执行\naysnc: 异步下载"),Object(r.b)("p",null,"HTML 网页中，浏览器通过",Object(r.b)("inlineCode",{parentName:"p"},"<script>"),"标签加载 JavaScript 脚本。"),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{}),'\x3c!-- 页面内嵌的脚本 --\x3e\n<script type="application/javascript">\n  // module code\n<\/script>\n\n\x3c!-- 外部脚本 --\x3e\n<script type="application/javascript" src="path/to/myModule.js">\n<\/script>\n')),Object(r.b)("p",null,'上面代码中，由于浏览器脚本的默认语言是 JavaScript，因此type="application/javascript"可以省略。'),Object(r.b)("p",null,"默认情况下，浏览器是同步加载 JavaScript 脚本，即渲染引擎遇到",Object(r.b)("inlineCode",{parentName:"p"},"<script>"),"标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间。"),Object(r.b)("p",null,"如果脚本体积很大，下载和执行的时间就会很长，因此造成浏览器堵塞，用户会感觉到浏览器“卡死”了，没有任何响应。这显然是很不好的体验，所以浏览器允许脚本异步加载，下面就是两种异步加载的语法。"),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{}),'<script src="path/to/myModule.js" defer><\/script>\n<script src="path/to/myModule.js" async><\/script>\n')),Object(r.b)("p",null,"上面代码中，",Object(r.b)("inlineCode",{parentName:"p"},"<script>"),"\n标签打开defer或async属性，脚本就会异步加载。渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令。"),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"defer与async的区别是"),"：defer要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；async一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"defer是“渲染完再执行”，async是“下载完就执行”。"),Object(r.b)("li",{parentName:"ul"},"多个defer脚本，会按照在页面出现的顺序加载，而多个async脚本是不能保证加载顺序的。")))}s.isMDXComponent=!0},396:function(e,n,t){"use strict";t.d(n,"a",(function(){return o})),t.d(n,"b",(function(){return u}));var r=t(0),a=t.n(r),c=a.a.createContext({}),p=function(e){var n=a.a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):Object.assign({},n,e)),t},o=function(e){var n=p(e.components);return a.a.createElement(c.Provider,{value:n},e.children)};var i="mdxType",l={inlineCode:"code",wrapper:function(e){var n=e.children;return a.a.createElement(a.a.Fragment,{},n)}},s=Object(r.forwardRef)((function(e,n){var t=e.components,r=e.mdxType,c=e.originalType,o=e.parentName,i=function(e,n){var t={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&-1===n.indexOf(r)&&(t[r]=e[r]);return t}(e,["components","mdxType","originalType","parentName"]),s=p(t),u=r,b=s[o+"."+u]||s[u]||l[u]||c;return t?a.a.createElement(b,Object.assign({},{ref:n},i,{components:t})):a.a.createElement(b,Object.assign({},{ref:n},i))}));function u(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var c=t.length,p=new Array(c);p[0]=s;var o={};for(var l in n)hasOwnProperty.call(n,l)&&(o[l]=n[l]);o.originalType=e,o[i]="string"==typeof e?e:r,p[1]=o;for(var u=2;u<c;u++)p[u]=t[u];return a.a.createElement.apply(null,p)}return a.a.createElement.apply(null,t)}s.displayName="MDXCreateElement"}}]);