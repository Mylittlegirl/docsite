(window.webpackJsonp=window.webpackJsonp||[]).push([[114],{246:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"rightToc",(function(){return c})),n.d(t,"default",(function(){return i}));n(0);var r=n(271);function a(){return(a=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e}).apply(this,arguments)}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},l=Object.keys(e);for(r=0;r<l.length;r++)n=l[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(r=0;r<l.length;r++)n=l[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var o={id:"reflow-repaint",title:"重排和重绘",sidebar_label:"重排和重绘"},c=[],b={rightToc:c},p="wrapper";function i(e){var t=e.components,n=l(e,["components"]);return Object(r.b)(p,a({},b,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("p",null,"根据渲染树布局，计算CSS样式，即每个节点在页面中的大小和位置等几何信息。HTML默认是流式布局的，CSS和JS会打破这种布局，改变DOM的外观样式以及大小和位置。这时就要提到两个重要概念：Reflow和Repaint。"),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Reflow/Layout"),"： 意味着元件的几何尺寸变了，我们需要重新验证并计算渲染树。是渲染树的一部分或全部发生了变化。这就是Reflow，或是Layout。\n",Object(r.b)("strong",{parentName:"p"},"Repaint"),"：屏幕的一部分重画，不影响整体布局，比如某个CSS的背景色变了，但元素的几何尺寸和位置不变。"),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},"常见引起重排属性和方法")),Object(r.b)("p",null,"任何会改变元素几何信息(元素的位置和尺寸大小)的操作，都会触发回流。"),Object(r.b)("p",null,"添加或者删除可见的DOM元素；"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"元素尺寸改变——边距、填充、边框、宽度和高度"),Object(r.b)("li",{parentName:"ul"},"内容变化，比如用户在input框中输入文字"),Object(r.b)("li",{parentName:"ul"},"浏览器窗口尺寸改变——resize事件发生时"),Object(r.b)("li",{parentName:"ul"},"计算 offsetWidth 和 offsetHeight 属性"),Object(r.b)("li",{parentName:"ul"},"设置 style 属性的值")),Object(r.b)("p",null,Object(r.b)("img",a({parentName:"p"},{src:"https://cosmos-x.oss-cn-hangzhou.aliyuncs.com/kh0bLF.png",alt:null}))),Object(r.b)("ol",{start:2},Object(r.b)("li",{parentName:"ol"},"常见引起重绘属性和方法")),Object(r.b)("p",null,Object(r.b)("img",a({parentName:"p"},{src:"https://cosmos-x.oss-cn-hangzhou.aliyuncs.com/bVJZq9.png",alt:null}))),Object(r.b)("p",null,"下面例子中，触发了几次回流和重绘？"),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{className:"language-js"}),'var s = document.body.style;\ns.padding = "2px"; // 回流+重绘\ns.border = "1px solid red"; // 再一次 回流+重绘\ns.color = "blue"; // 再一次重绘\ns.backgroundColor = "#ccc"; // 再一次 重绘\ns.fontSize = "14px"; // 再一次 回流+重绘\n// 添加node，再一次 回流+重绘\ndocument.body.appendChild(document.createTextNode(\'abc!\'));\n')),Object(r.b)("ol",{start:3},Object(r.b)("li",{parentName:"ol"},"如何减少回流、重绘")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"使用 transform 替代 top"),Object(r.b)("li",{parentName:"ul"},"使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局）"),Object(r.b)("li",{parentName:"ul"},"不要把节点的属性值放在一个循环里当成循环里的变量。")),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{className:"language-js"}),"for(let i = 0; i < 1000; i++) {\n    // 获取 offsetTop 会导致回流，因为需要去获取正确的值\n    console.log(document.querySelector('.test').style.offsetTop)\n}\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局"),Object(r.b)("li",{parentName:"ul"},"动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame"),Object(r.b)("li",{parentName:"ul"},"CSS 选择符从右往左匹配查找，避免节点层级过多"),Object(r.b)("li",{parentName:"ul"},"将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点。比如对于 video 标签来说，浏览器会自动将该节点变为图层。")),Object(r.b)("p",null,"有些情况下，比如修改了元素的样式，浏览器并不会立刻 reflow 或 repaint 一次，而是会把这样的操作积攒一批，然后做一次 reflow，这又叫异步 reflow 或增量异步 reflow。有些情况下，比如 resize 窗口，改变了页面默认的字体等。对于这些操作，浏览器会马上进行 reflow。"))}i.isMDXComponent=!0},271:function(e,t,n){"use strict";n.d(t,"a",(function(){return c})),n.d(t,"b",(function(){return u}));var r=n(0),a=n.n(r),l=a.a.createContext({}),o=function(e){var t=a.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):Object.assign({},t,e)),n},c=function(e){var t=o(e.components);return a.a.createElement(l.Provider,{value:t},e.children)};var b="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},i=Object(r.forwardRef)((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,c=e.parentName,b=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&-1===t.indexOf(r)&&(n[r]=e[r]);return n}(e,["components","mdxType","originalType","parentName"]),i=o(n),u=r,s=i[c+"."+u]||i[u]||p[u]||l;return n?a.a.createElement(s,Object.assign({},{ref:t},b,{components:n})):a.a.createElement(s,Object.assign({},{ref:t},b))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,o=new Array(l);o[0]=i;var c={};for(var p in t)hasOwnProperty.call(t,p)&&(c[p]=t[p]);c.originalType=e,c[b]="string"==typeof e?e:r,o[1]=c;for(var u=2;u<l;u++)o[u]=n[u];return a.a.createElement.apply(null,o)}return a.a.createElement.apply(null,n)}i.displayName="MDXCreateElement"}}]);