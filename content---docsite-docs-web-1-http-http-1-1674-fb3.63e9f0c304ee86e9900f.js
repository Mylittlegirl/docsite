(window.webpackJsonp=window.webpackJsonp||[]).push([[69],{154:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return p})),n.d(t,"rightToc",(function(){return c})),n.d(t,"default",(function(){return u}));n(0);var r=n(193);function a(){return(a=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e}).apply(this,arguments)}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},l=Object.keys(e);for(r=0;r<l.length;r++)n=l[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(r=0;r<l.length;r++)n=l[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var p={id:"http1.1",title:"HTTP1.1",sidebar_label:"HTTP1.1"},c=[{value:"长连接",id:"长连接",children:[]},{value:"管道机制",id:"管道机制",children:[]}],o={rightToc:c},i="wrapper";function u(e){var t=e.components,n=l(e,["components"]);return Object(r.b)(i,a({},o,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("h2",{id:"长连接"},"长连接"),Object(r.b)("p",null,"一个HTTP的通信生命周期通过 Request 来界定，也就是一个 Request 一个 Response ，那么在 HTTP1.0 中，这次HTTP请求就结束了。为了解决这个问题，有些浏览器在请求时，用了一个非标准的Connection字段：Connection: keep-alive，但这个并不是标准字段。\n即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。"),Object(r.b)("p",null,"1.1 版的最大变化，就是引入了",Object(r.b)("strong",{parentName:"p"},"持久连接（persistent connection）"),"，客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送Connection: close，明确要求服务器关闭TCP连接。"),Object(r.b)("p",null,"目前，对于同一个域名，大多数浏览器允许同时建立6个持久连接。"),Object(r.b)("p",null,"没有数据传也要保持tcp连接就是长连接。反之就是短连接。"),Object(r.b)("p",null,"在HTTP1.1中进行了改进，有了一个keep-alive，在一个HTTP连接中，可以发送多个Request，接收多个Response，也就是合并多个请求。但是一个Request只能对应一个Response，而且这个Response是被动的，不能主动发起。"),Object(r.b)("p",null,"Keep-Alive解决的核心问题：一定时间内，同一域名多次请求数据，只建立一次HTTP请求，其他请求可复用每一次建立的连接通道，以达到提高请求效率的问题。这里面所说的一定时间是可以配置的，不管你用的是Apache还是nginx。"),Object(r.b)("p",null,"长接连的特点：只要任意一端没有明确提出断开连接，则保持TCP连接状态。"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"开启：http 1.1中默认启用Keep-Alive，目前大部分浏览器都是用http1.1协议，也就是说默认都会发起Keep-Alive的连接请求。"),Object(r.b)("li",{parentName:"ul"},"关闭：在http头中设置Connection: close，即可关闭。"),Object(r.b)("li",{parentName:"ul"},"设置连接时间： 在http header中设置Keep-Alive: timeout=5, max=1000， timeout是超时时间，单位秒，超过这个时间后就断开连接， max是最多的连接次数，若超过这个次数就强制断开连接。")),Object(r.b)("p",null,"Keep-Alive，他解决了多次连接的问题，但是依然有两个效率上的问题："),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"串行的文件传输。当请求a文件时，b文件只能等待，等待a连接到服务器、服务器处理文件、服务器返回文件，这三个步骤。我们假设这三步用时都是1秒，那么a文件用时为3秒，b文件传输完成用时为6秒，依此类推。（注：此项计算有一个前提条件，就是浏览器和服务器是单通道传输）")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"连接数过多。我们假设Apache设置了最大并发数为300，因为浏览器限制，浏览器发起的最大请求数为6，也就是服务器能承载的最高并发为50，当第51个人访问时，就需要等待前面某个请求处理完成。"))),Object(r.b)("h2",{id:"管道机制"},"管道机制"),Object(r.b)("p",null," HTTP/1.1 版还引入了管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。"),Object(r.b)("p",null,"举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发出B请求。",Object(r.b)("em",{parentName:"p"},"管道机制则是允许浏览器同时发出A请求和B请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求"),"。"),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"由于浏览器供应商难以实现，现被禁用或删除")),Object(r.b)("p",null,Object(r.b)("img",a({parentName:"p"},{src:"https://raw.githubusercontent.com/ThinkBucket/oss/master/Q34xeD.png",alt:null}))))}u.isMDXComponent=!0},193:function(e,t,n){"use strict";n.d(t,"a",(function(){return c})),n.d(t,"b",(function(){return b}));var r=n(0),a=n.n(r),l=a.a.createContext({}),p=function(e){var t=a.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):Object.assign({},t,e)),n},c=function(e){var t=p(e.components);return a.a.createElement(l.Provider,{value:t},e.children)};var o="mdxType",i={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},u=Object(r.forwardRef)((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,c=e.parentName,o=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&-1===t.indexOf(r)&&(n[r]=e[r]);return n}(e,["components","mdxType","originalType","parentName"]),u=p(n),b=r,s=u[c+"."+b]||u[b]||i[b]||l;return n?a.a.createElement(s,Object.assign({},{ref:t},o,{components:n})):a.a.createElement(s,Object.assign({},{ref:t},o))}));function b(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,p=new Array(l);p[0]=u;var c={};for(var i in t)hasOwnProperty.call(t,i)&&(c[i]=t[i]);c.originalType=e,c[o]="string"==typeof e?e:r,p[1]=c;for(var b=2;b<l;b++)p[b]=n[b];return a.a.createElement.apply(null,p)}return a.a.createElement.apply(null,n)}u.displayName="MDXCreateElement"}}]);