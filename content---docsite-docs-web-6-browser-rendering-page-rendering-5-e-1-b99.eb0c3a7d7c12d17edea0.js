(window.webpackJsonp=window.webpackJsonp||[]).push([[102],{220:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return l})),n.d(t,"rightToc",(function(){return p})),n.d(t,"default",(function(){return b}));n(0);var r=n(249);function a(){return(a=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e}).apply(this,arguments)}function c(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},c=Object.keys(e);for(r=0;r<c.length;r++)n=c[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var c=Object.getOwnPropertySymbols(e);for(r=0;r<c.length;r++)n=c[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l={id:"page-rendering",title:"页面渲染",sidebar_label:"页面渲染"},p=[],o={rightToc:p},i="wrapper";function b(e){var t=e.components,n=c(e,["components"]);return Object(r.b)(i,a({},o,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("p",null,"浏览器工作流程大体分为如下三部分："),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},"浏览器会解析三个东西：")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"一个是HTML/SVG/XHTML，事实上，Webkit有三个C++的类对应这三类文档。解析这三种文件会产生一个DOM Tree。"),Object(r.b)("li",{parentName:"ul"},"CSS，解析CSS会产生CSS规则树。"),Object(r.b)("li",{parentName:"ul"},"Javascript，脚本，主要是通过DOM API和CSSOM API来操作DOM Tree和CSS Rule Tree.")),Object(r.b)("ol",{start:2},Object(r.b)("li",{parentName:"ol"},"解析完成后，浏览器引擎会通过DOM Tree 和 CSS Rule Tree 来构造 Rendering Tree。")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"Rendering Tree 渲染树并不等同于DOM树，因为一些像",Object(r.b)("inlineCode",{parentName:"li"},"<headr>"),"元素或CSS设置display:none的节点就没必要放在渲染树中了。"),Object(r.b)("li",{parentName:"ul"},"CSS 的 Rule Tree主要是为了完成匹配并把CSS Rule附加上Rendering Tree上的每个Element。也就是DOM结点。也就是所谓的Frame。"),Object(r.b)("li",{parentName:"ul"},"然后，计算每个Frame（也就是每个Element）的位置，这又叫layout和reflow过程。")),Object(r.b)("ol",{start:3},Object(r.b)("li",{parentName:"ol"},"最后通过调用操作系统Native GUI(图像用户接口)的API绘制。")),Object(r.b)("p",null,Object(r.b)("img",a({parentName:"p"},{src:"https://cosmos-x.oss-cn-hangzhou.aliyuncs.com/kBpnEt.png",alt:null}))),Object(r.b)("p",null,Object(r.b)("a",a({parentName:"p"},{href:"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction?hl=zh-cn"}),"如上图所示"),"，在DOM树和CSS规则树合并成渲染树的时候会忽略",Object(r.b)("inlineCode",{parentName:"p"},"<head>"),"等不可见节点和设置了样式为display:none的节点。生成渲染树后然后进入布局，布局计算每个对象的精确位置和大小，然后通过绘制，呈现出页面。"),Object(r.b)("p",null,Object(r.b)("img",a({parentName:"p"},{src:"https://cosmos-x.oss-cn-hangzhou.aliyuncs.com/HHhHC2.png",alt:null})),"\n",Object(r.b)("img",a({parentName:"p"},{src:"https://cosmos-x.oss-cn-hangzhou.aliyuncs.com/s6T92W.png",alt:null}))),Object(r.b)("p",null,"浏览器工作流程：构建DOM -> 构建CSSOM -> 构建渲染树 -> 布局 -> 绘制。"),Object(r.b)("p",null,"CSSOM会阻塞渲染，只有当CSSOM构建完毕后才会进入下一个阶段构建渲染树。"),Object(r.b)("p",null,"通常情况下DOM和CSSOM是",Object(r.b)("inlineCode",{parentName:"p"},"并行构建"),"的，但是当浏览器遇到一个script标签时，DOM构建将暂停，直至脚本完成执行。但由于JavaScript可以修改CSSOM，所以",Object(r.b)("inlineCode",{parentName:"p"},"需要等CSSOM构建完毕后再执行JS"),"。"),Object(r.b)("p",null,Object(r.b)("a",a({parentName:"p"},{href:"https://juejin.im/post/5b88ddca6fb9a019c7717096#heading-4"}),"https://juejin.im/post/5b88ddca6fb9a019c7717096#heading-4")),Object(r.b)("p",null,"如果你想首屏渲染的更快，就应该在首屏减少加载 JS 文件，且将 script 标签放在 body 标签底部。"),Object(r.b)("p",null,"JavaScript的加载、解析与执行会阻塞DOM的构建，也就是说，在构建DOM时，HTML解析器若遇到了JavaScript，那么它会暂停构建DOM，将控制权移交给JavaScript引擎，等JavaScript引擎运行完毕，浏览器再从中断的地方恢复DOM构建。"),Object(r.b)("p",null,"也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性。"),Object(r.b)("p",null,"JS文件不只是阻塞DOM的构建，它会导致CSSOM也阻塞DOM的构建。"),Object(r.b)("p",null,"原本DOM和CSSOM的构建是互不影响，井水不犯河水，但是一旦引入了JavaScript，CSSOM也开始阻塞DOM的构建，只有CSSOM构建完毕后，DOM再恢复DOM构建。"),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"这是什么情况？")),Object(r.b)("p",null,"这是因为JavaScript不只是可以改DOM，它还可以更改样式，也就是它可以更改CSSOM。前面我们介绍，不完整的CSSOM是无法使用的，但JavaScript中想访问CSSOM并更改它，那么在执行JavaScript时，必须要能拿到完整的CSSOM。所以就导致了一个现象，如果浏览器尚未完成CSSOM的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟脚本执行和DOM构建，直至其完成CSSOM的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建CSSOM，然后再执行JavaScript，最后在继续构建DOM。"),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},Object(r.b)("a",a({parentName:"strong"},{href:"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-blocking-css?hl=zh-cn"}),"CSS会不会阻塞页面的渲染？"))),Object(r.b)("p",null,"默认情况下，CSS 被视为阻塞渲染的资源，这意味着浏览器将不会渲染任何已处理的内容，直至 CSSOM 构建完毕。所以CSS也需要精简、减少Reflow和Repaint。"))}b.isMDXComponent=!0},249:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return O}));var r=n(0),a=n.n(r),c=a.a.createContext({}),l=function(e){var t=a.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):Object.assign({},t,e)),n},p=function(e){var t=l(e.components);return a.a.createElement(c.Provider,{value:t},e.children)};var o="mdxType",i={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},b=Object(r.forwardRef)((function(e,t){var n=e.components,r=e.mdxType,c=e.originalType,p=e.parentName,o=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&-1===t.indexOf(r)&&(n[r]=e[r]);return n}(e,["components","mdxType","originalType","parentName"]),b=l(n),O=r,u=b[p+"."+O]||b[O]||i[O]||c;return n?a.a.createElement(u,Object.assign({},{ref:t},o,{components:n})):a.a.createElement(u,Object.assign({},{ref:t},o))}));function O(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var c=n.length,l=new Array(c);l[0]=b;var p={};for(var i in t)hasOwnProperty.call(t,i)&&(p[i]=t[i]);p.originalType=e,p[o]="string"==typeof e?e:r,l[1]=p;for(var O=2;O<c;O++)l[O]=n[O];return a.a.createElement.apply(null,l)}return a.a.createElement.apply(null,n)}b.displayName="MDXCreateElement"}}]);