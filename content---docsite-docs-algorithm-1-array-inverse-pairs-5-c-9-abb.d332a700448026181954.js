(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{396:function(n,e,t){"use strict";t.d(e,"a",(function(){return c})),t.d(e,"b",(function(){return p}));var r=t(0),a=t.n(r),i=a.a.createContext({}),o=function(n){var e=a.a.useContext(i),t=e;return n&&(t="function"==typeof n?n(e):Object.assign({},e,n)),t},c=function(n){var e=o(n.components);return a.a.createElement(i.Provider,{value:e},n.children)};var l="mdxType",u={inlineCode:"code",wrapper:function(n){var e=n.children;return a.a.createElement(a.a.Fragment,{},e)}},s=Object(r.forwardRef)((function(n,e){var t=n.components,r=n.mdxType,i=n.originalType,c=n.parentName,l=function(n,e){var t={};for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&-1===e.indexOf(r)&&(t[r]=n[r]);return t}(n,["components","mdxType","originalType","parentName"]),s=o(t),p=r,b=s[c+"."+p]||s[p]||u[p]||i;return t?a.a.createElement(b,Object.assign({},{ref:e},l,{components:t})):a.a.createElement(b,Object.assign({},{ref:e},l))}));function p(n,e){var t=arguments,r=e&&e.mdxType;if("string"==typeof n||r){var i=t.length,o=new Array(i);o[0]=s;var c={};for(var u in e)hasOwnProperty.call(e,u)&&(c[u]=e[u]);c.originalType=n,c[l]="string"==typeof n?n:r,o[1]=c;for(var p=2;p<i;p++)o[p]=t[p];return a.a.createElement.apply(null,o)}return a.a.createElement.apply(null,t)}s.displayName="MDXCreateElement"},74:function(n,e,t){"use strict";t.r(e),t.d(e,"frontMatter",(function(){return o})),t.d(e,"rightToc",(function(){return c})),t.d(e,"default",(function(){return s}));t(0);var r=t(396);function a(){return(a=Object.assign||function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(n[r]=t[r])}return n}).apply(this,arguments)}function i(n,e){if(null==n)return{};var t,r,a=function(n,e){if(null==n)return{};var t,r,a={},i=Object.keys(n);for(r=0;r<i.length;r++)t=i[r],e.indexOf(t)>=0||(a[t]=n[t]);return a}(n,e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(n);for(r=0;r<i.length;r++)t=i[r],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(a[t]=n[t])}return a}var o={id:"inverse-pairs",title:"数组中的逆序对",sidebar_label:"数组中的逆序对"},c=[{value:"题目",id:"题目",children:[]},{value:"思路",id:"思路",children:[]},{value:"代码实现",id:"代码实现",children:[]}],l={rightToc:c},u="wrapper";function s(n){var e=n.components,t=i(n,["components"]);return Object(r.b)(u,a({},l,t,{components:e,mdxType:"MDXLayout"}),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"题源：《剑指Offer: 面试题 51》P249"),Object(r.b)("li",{parentName:"ul"},"在线：",Object(r.b)("a",a({parentName:"li"},{href:"https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5"}),"牛客网"))),Object(r.b)("h2",{id:"题目"},"题目"),Object(r.b)("p",null,"在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。"),Object(r.b)("p",null,"示例:"),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{className:"language-text"}),"输入: [7,5,6,4]\n输出: 5\n")),Object(r.b)("p",null,"该数组总共 5 个逆序对，分别是 (7,6), (7,5), (7,4), (6,4) 和 (5,4)。"),Object(r.b)("h2",{id:"思路"},"思路"),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},"最容易想到的是蛮力法但时间复杂度为 O(n2)"),Object(r.b)("li",{parentName:"ol"},"以空间换时间：对该数组进行",Object(r.b)("strong",{parentName:"li"},"归并排序"),"，先分后合，合的过程中统计逆序对，时间复杂度为 O(nlogn)，但同时需要一个 O(n) 的辅助空间")),Object(r.b)("div",{align:"center"},Object(r.b)("img",{width:"630",src:"https://cosmos-x.oss-cn-hangzhou.aliyuncs.com/zX1Diu.png"}),Object(r.b)("p",null,"图1：先分后并进行归并排序，并统计逆序对")),Object(r.b)("p",null,"如图2(a)中，7 > 6, 6 及其前面有 2 个数，所以算 2 个逆序对："),Object(r.b)("div",{align:"center"},Object(r.b)("img",{width:"630",src:"https://cosmos-x.oss-cn-hangzhou.aliyuncs.com/9GHK67.png"}),Object(r.b)("p",null,"图2：子数组由后往前进行比较合并，并在过程中统计逆序对")),Object(r.b)("h2",{id:"代码实现"},"代码实现"),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{className:"language-js"}),"let count = 0;\n\nfunction inversePairs (nums) {\n    sortArray(nums);\n    return count;\n}\n\nfunction sortArray (nums, from = 0, to = nums.length - 1) {\n    // 分割到一个元素的时候开始合并\n    if (from === to) {\n        return [nums[from]];\n    }\n    let mid = from + (to - from >> 1);\n    let left = sortArray(nums, from, mid);\n    let right = sortArray(nums, mid + 1, to);\n    return merge(left, right);\n}\n\nfunction merge (left, right) {\n    let ans = [];\n    // 注意是从后开始\n    let i = left.length - 1;\n    let j = right.length - 1;\n    while (i >= 0 && j >= 0) {\n        if (left[i] > right[j]) {\n            // 从后往前插入比较大的值\n            ans.unshift(left[i--]);\n            // 表明 left[i] 比 right[j] 以及之前都大\n            count += j + 1;\n        } else {\n            ans.unshift(right[j--]);\n        }\n    }\n    while (i >= 0) {\n        ans.unshift(left[i--]);\n    }\n    while (j >= 0) {\n        ans.unshift(right[j--]);\n    }\n    return ans;\n}\n")))}s.isMDXComponent=!0}}]);