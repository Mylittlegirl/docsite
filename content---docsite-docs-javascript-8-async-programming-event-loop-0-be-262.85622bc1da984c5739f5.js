(window.webpackJsonp=window.webpackJsonp||[]).push([[84],{196:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"rightToc",(function(){return l})),n.d(t,"default",(function(){return p}));n(0);var r=n(396);function a(){return(a=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e}).apply(this,arguments)}function c(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},c=Object.keys(e);for(r=0;r<c.length;r++)n=c[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var c=Object.getOwnPropertySymbols(e);for(r=0;r<c.length;r++)n=c[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var o={title:"Event Loop",sidebar_label:"Event Loop"},l=[{value:"浏览器事件循环",id:"浏览器事件循环",children:[]},{value:"相关拓展",id:"相关拓展",children:[]}],i={rightToc:l},u="wrapper";function p(e){var t=e.components,n=c(e,["components"]);return Object(r.b)(u,a({},i,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("h2",{id:"浏览器事件循环"},"浏览器事件循环"),Object(r.b)("p",null,"事件循环可以理解成由三部分组成，分别是："),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"主线程执行栈"),Object(r.b)("li",{parentName:"ul"},"异步任务等待触发"),Object(r.b)("li",{parentName:"ul"},"任务队列")),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"任务队列"),"(task queue)就是以队列的数据结构对事件任务进行管理，特点是先进先出，后进后出。"),Object(r.b)("div",{align:"center"},Object(r.b)("img",{width:"792",src:"https://cosmos-x.oss-cn-hangzhou.aliyuncs.com/image61.png"})),Object(r.b)("p",null,"在JS引擎主线程执行过程中："),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"首先执行宏任务的同步任务，在主线程上形成一个执行栈，可理解为函数调用栈；"),Object(r.b)("li",{parentName:"ul"},"当执行栈中的函数调用到一些异步执行的API（例如异步Ajax，DOM事件，setTimeout等API），则会开启对应的线程（Http异步请求线程，事件触发线程和定时器触发线程）进行监控和控制"),Object(r.b)("li",{parentName:"ul"},"当异步任务的事件满足触发条件时，对应的线程则会把该事件的处理函数推进任务队列(task queue)中，等待主线程读取执行"),Object(r.b)("li",{parentName:"ul"},"当JS引擎主线程上的任务执行完毕，则会读取任务队列中的事件，将任务队列中的事件任务推进主线程中，按任务队列顺序执行"),Object(r.b)("li",{parentName:"ul"},"当JS引擎主线程上的任务执行完毕后，则会再次读取任务队列中的事件任务，如此循环，这就是事件循环（Event Loop）的过程")),Object(r.b)("p",null,"这就是加入微任务后的详细事件循环："),Object(r.b)("p",null,Object(r.b)("img",a({parentName:"p"},{src:"https://cosmos-x.oss-cn-hangzhou.aliyuncs.com/image9.png",alt:null}))),Object(r.b)("p",null,"在事件循环中，每进行一次循环操作称为 tick，每一次 tick 的任务处理模型是比较复杂的，但关键步骤如下：\n1. 执行一个宏任务（栈中没有就从事件队列中获取）\n2. 执行过程中如果遇到微任务，就将它添加(没有执行)到微任务的任务队列中\n3. 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）\n4. 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染\n5. 渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）"),Object(r.b)("p",null,"流程图如下："),Object(r.b)("p",null,Object(r.b)("img",a({parentName:"p"},{src:"https://cosmos-x.oss-cn-hangzhou.aliyuncs.com/image63.png",alt:null}))),Object(r.b)("p",null,"浏览器事件循环经典题目:"),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{className:"language-js"}),"for (var i=0; i<5; i++) {\n    setTimeout( function timer() {\n        console.log(new Date, i);\n    }, 1000);\n}\n/* VM84:3 Wed Oct 09 2019 09:29:47 GMT+0800 (中国标准时间) 5\nVM84:3 Wed Oct 09 2019 09:29:47 GMT+0800 (中国标准时间) 5\nVM84:3 Wed Oct 09 2019 09:29:47 GMT+0800 (中国标准时间) 5\nVM84:3 Wed Oct 09 2019 09:29:47 GMT+0800 (中国标准时间) 5\nVM84:3 Wed Oct 09 2019 09:29:47 GMT+0800 (中国标准时间) 5 */\n")),Object(r.b)("p",null,"解析： 根据setTimeout定义的操作在函数调用栈清空之后才会执行的特点，for循环里定义了5个setTimeout操作。而等待1秒后，任务队列里的setTimeout开始依次执行时，for循环的i值，已经先一步变成了5。因为任务队列推到函数调用栈执行的时间可以忽略不记（毫秒级），所以打印的GMT时间（精确到秒）和i的值都是相同的。"),Object(r.b)("p",null,"解决这个问题有三种方法：\n1. 使用闭包\n2. 使用let定义变量 i\n3. 使用setTimeOut的第三个参数，将第三个参数作为setTimeout回调函数。"),Object(r.b)("p",null,Object(r.b)("a",a({parentName:"p"},{href:"https://thinkbucket.github.io/docsite/blog/setTimeOut"}),"点击查看三种解决方案")),Object(r.b)("h2",{id:"相关拓展"},"相关拓展"),Object(r.b)("p",null,Object(r.b)("a",a({parentName:"p"},{href:"https://zhuanlan.zhihu.com/p/34182184"}),"Event Loop 必知必会（六道题）")))}p.isMDXComponent=!0},396:function(e,t,n){"use strict";n.d(t,"a",(function(){return l})),n.d(t,"b",(function(){return b}));var r=n(0),a=n.n(r),c=a.a.createContext({}),o=function(e){var t=a.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):Object.assign({},t,e)),n},l=function(e){var t=o(e.components);return a.a.createElement(c.Provider,{value:t},e.children)};var i="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},p=Object(r.forwardRef)((function(e,t){var n=e.components,r=e.mdxType,c=e.originalType,l=e.parentName,i=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&-1===t.indexOf(r)&&(n[r]=e[r]);return n}(e,["components","mdxType","originalType","parentName"]),p=o(n),b=r,s=p[l+"."+b]||p[b]||u[b]||c;return n?a.a.createElement(s,Object.assign({},{ref:t},i,{components:n})):a.a.createElement(s,Object.assign({},{ref:t},i))}));function b(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var c=n.length,o=new Array(c);o[0]=p;var l={};for(var u in t)hasOwnProperty.call(t,u)&&(l[u]=t[u]);l.originalType=e,l[i]="string"==typeof e?e:r,o[1]=l;for(var b=2;b<c;b++)o[b]=n[b];return a.a.createElement.apply(null,o)}return a.a.createElement.apply(null,n)}p.displayName="MDXCreateElement"}}]);