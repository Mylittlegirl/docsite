(window.webpackJsonp=window.webpackJsonp||[]).push([[90],{198:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return c})),t.d(n,"rightToc",(function(){return s})),t.d(n,"default",(function(){return o}));t(0);var r=t(277);function a(){return(a=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r])}return e}).apply(this,arguments)}function l(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},l=Object.keys(e);for(r=0;r<l.length;r++)t=l[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(r=0;r<l.length;r++)t=l[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var c={id:"IndexedDB",title:"indexedDB",sidebar_label:"indexedDB"},s=[{value:"indexedDB",id:"indexeddb",children:[]},{value:"创建一个数据库",id:"创建一个数据库",children:[]},{value:"创建一个表：对象仓库",id:"创建一个表：对象仓库",children:[]},{value:"创建事务",id:"创建事务",children:[]},{value:"增删改查",id:"增删改查",children:[]},{value:"索引",id:"索引",children:[]}],b={rightToc:s},u="wrapper";function o(e){var n=e.components,t=l(e,["components"]);return Object(r.b)(u,a({},b,t,{components:n,mdxType:"MDXLayout"}),Object(r.b)("h2",{id:"indexeddb"},"indexedDB"),Object(r.b)("p",null,"IndexedDB(索引数据库) 是一个为了能够在浏览器端存储大量数据，可以离线使用和使用索引进行高性能检索。其实它就是一个基于",Object(r.b)("strong",{parentName:"p"},"事务操作"),"的key-value型数前端NoSQL数据库，其API是异步的。基本操作就是，打开数据库，增删改查。"),Object(r.b)("p",null,"应用：\n大的数据在本地临时存储，比如谷歌文档可能是为了离线存储，待联网的时候自动把保存本地的更新到服务器。\n联合使用IndexedDB储存离线数据和Service Workers储存离线资源，制作离线PWA，如",Object(r.b)("a",a({parentName:"p"},{href:"https://h5.ele.me/%E3%80%82"}),"https://h5.ele.me/。")),Object(r.b)("p",null,"IndexedDB 具有以下特点:"),Object(r.b)("p",null,'（1）键值对储存。 IndexedDB 内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括 JavaScript 对象。对象仓库中，数据以"键值对"的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。'),Object(r.b)("p",null,"（2）异步。 IndexedDB 操作时不会锁死浏览器，用户依然可以进行其他操作，这与 LocalStorage 形成对比，后者的操作是同步的。异步设计是为了防止大量数据的读写，拖慢网页的表现。"),Object(r.b)("p",null,"（3）支持事务。 IndexedDB 支持事务（transaction），这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。"),Object(r.b)("p",null,"（4）同源限制 IndexedDB 受到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。"),Object(r.b)("p",null,"（5）储存空间大 IndexedDB 的储存空间比 LocalStorage 大得多，一般来说不少于 250MB，甚至没有上限。"),Object(r.b)("p",null,"（6）支持二进制储存。 IndexedDB 不仅可以储存字符串，还可以储存二进制数据（ArrayBuffer 对象和 Blob 对象）。"),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"基本原理：")),Object(r.b)("p",null,"要异步访问数据库，要调用 window 对象 indexedDB 属性的 open() 方法。该方法返回一个 IDBRequest 对象 (IDBOpenDBRequest)；异步操作通过在 IDBRequest 对象上触发事件来和调用程序进行通信。"),Object(r.b)("h2",{id:"创建一个数据库"},"创建一个数据库"),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{className:"language-js"}),"const request = indexedDB.open('myDatabase', 1);\nrequest.addEventListener('success', e => {\n    console.log('连接数据库成功');\n});\nrequest.addEventListener('error', e => {\n    console.log('连接数据库失败');\n});\n")),Object(r.b)("p",null,"在上面代码中我们使用 indexedDB.open() 创建一个indexedDB数据库.open()方法接受可以接受两个参数："),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"数据库名"),Object(r.b)("li",{parentName:"ul"},"数据库的版本号")),Object(r.b)("p",null,"同时返回一个IDBOpenDBRequest对象用于操作数据库.其中对于open()的第一个参数数据库名,open()会先去查找本地是否已有这个数据库,如果有则直接将这个数据库返回,如果没有,则先创建这个数据库,再返回.对于第二个参数版本号,则是一个可选参数,如果不传,默认为1.但如果传入就必须是一个整数."),Object(r.b)("p",null,"在通过对indexedDB.open()方法拿到一个数据库对象IDBOpenDBRequest我们可以通过监听这个对象的success事件和error事件来执行相应的操作."),Object(r.b)("h2",{id:"创建一个表：对象仓库"},"创建一个表：对象仓库"),Object(r.b)("p",null,"有了一个数据库之后,我们获取就想要去存储数据了,但是单只有数据库还不够,我们还需要有对象仓库(object store).对象仓库(object store)是indexedDB数据库的基础,其类似于MySQL中表的概念."),Object(r.b)("p",null,"要创建一个对象仓库必须在upgradeneeded事件中,而upgradeneeded事件只会在版本号更新的时候触发.这是因为indexedDB API中",Object(r.b)("strong",{parentName:"p"},"不允许数据仓库在同一版本中发生变化"),"："),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{className:"language-js"}),"const request = indexedDB.open('myDatabase', 2);\nrequest.addEventListener('upgradeneeded', e => {\n    const db = e.target.result;\n    const store = db.createObjectStore('Users', {\n        keyPath: 'userId',\n        autoIncrement: false\n    });\n    console.log('创建对象仓库成功');\n});\n")),Object(r.b)("p",null,"在上述代码中我们监听upgradeneeded事件,并在这个事件触发时使用createObjectStore()方法创建了一个对象仓库.createObjectStore()方法接受两个参数："),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"对象仓库的名字,在同一数据库中,仓库名不能重复"),Object(r.b)("li",{parentName:"ul"},"可选参数.用于指定数据的主键,以及是否自增主键")),Object(r.b)("h2",{id:"创建事务"},"创建事务"),Object(r.b)("p",null,"简单来说事务就是用来保证数据库操作要么全部成功，要么全部失败的一个限制。"),Object(r.b)("p",null,"比如,在修改多条数据时,前面几条已经成功了.,在中间的某一条是失败了.那么在这时,如果是基于事务的数据库操作,那么这时数据库就应该重置前面数据的修改,放弃后面的数据修改.直接返回错误,一条数据也不修改。"),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{className:"language-js"}),"const request = indexedDB.open('myDatabase', 3);\nrequest.addEventListener('success', e => {\n    const db = e.target.result;\n    const tx = db.transaction('Users', 'readwrite');\n});\n")),Object(r.b)("p",null,"上述代码中我们使用transaction()来创建一个事务，它接受两个参数："),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"你要操作的对象仓库名称。"),Object(r.b)("li",{parentName:"ul"},"你创建的事务模式：传入 readonly时只能对对象仓库进行读操作，无法写操作。可以传入readwrite进行读写操作。")),Object(r.b)("h2",{id:"增删改查"},"增删改查"),Object(r.b)("p",null,"好了现在有了数据库,对象仓库,事务之后我们终于可以存储数据了："),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"add() : 增加数据。接收一个参数，为需要保存到对象仓库中的对象。"),Object(r.b)("li",{parentName:"ul"},"put() : 增加或修改数据。接收一个参数，为需要保存到对象仓库中的对象。"),Object(r.b)("li",{parentName:"ul"},"get() : 获取数据。接收一个参数，为需要获取数据的主键值。"),Object(r.b)("li",{parentName:"ul"},"delete() : 删除数据。接收一个参数，为需要获取数据的主键值。")),Object(r.b)("p",null,"add 和 put 的作用类似，区别在于 put 保存数据时，如果该数据的主键在数据库中已经有相同主键的时候，则会修改数据库中对应主键的对象，而使用 add 保存数据，如果该主键已经存在，则保存失败。"),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{className:"language-js"}),"const request = indexedDB.open('myDatabase', 3);\nrequest.addEventListener('success', e => {\n    const db = e.target.result;\n    const tx = db.transaction('Users', 'readwrite');\n    const store = tx.objectStore('Users');\n    const reqAdd = store.add({\n        'userId': 1,\n        'userName': '李白',\n        'age': 24\n    });\n    const reqGet = store.get(1);\n    const reqDelete = store.delete(1);\n    reqAdd.addEventListener('success', e => {\n        console.log('操作成功')  // delete 同理\n    })\n    reqGet.addEventListener('success', e => {\n        console.log(this.result.userName);\n    })\n});\n")),Object(r.b)("p",null,"10.2.5 游标\n在上面当中我们使用get()方法传入一个主键来获取数据，但是这样只能够获取到一条数据。如果我们想要获取多条数据了怎么办？",Object(r.b)("strong",{parentName:"p"},"我们可以使用游标，来获取一个区间内的数据。")),Object(r.b)("p",null,"要使用游标，我们需要使用对象仓库上的 openCursor() 方法创建并打开 .openCursor() 方法接受两个参数："),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{className:"language-js"}),"openCursor(\n  range?: IDBKeyRange | number | string | Date | IDBArrayKey,\n  direction?: IDBCursorDirection\n): IDBRequest;\n")),Object(r.b)("p",null,"第一个是范围，范围可以是一个IDBKeyRange对象，用以下方式创建："),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{className:"language-js"}),"var boundRange = IDBKeyRange.bound(1, 10, false, false);\nvar onlyRange = IDBKeyRange.only(1);\nvar lowerRange = IDBKeyRange.lowerBound(1, false);\nvar upperRange = IDBKeyRange.upperBound(10, false);\n")),Object(r.b)("p",null,"第二个参数是方向，主要有一下几种："),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"next : 游标中的数据按主键值升序排列，主键值相等的数据都被读取"),Object(r.b)("li",{parentName:"ul"},"nextunique : 游标中的数据按主键值升序排列，主键值相等只读取第一条数据"),Object(r.b)("li",{parentName:"ul"},"prev : 游标中的数据按主键值降序排列，主键值相等的数据都被读取"),Object(r.b)("li",{parentName:"ul"},"prevunique : 游标中的数据按主键值降序排列，主键值相等只读取第一条数据")),Object(r.b)("p",null,"下面让我们来看一个完整的例子："),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{className:"language-js"}),"const request = indexedDB.open('myDatabase', 4);\nrequest.addEventListener('success', e => {\n    const db = e.target.result;\n    const tx = db.transaction('Users', 'readwrite');\n    const store = tx.objectStore('Users');\n    const range = IDBKeyRange.bound(1, 10);\n    const req = store.openCursor(range, 'next');\n    req.addEventListener('success', e => {\n        const cursor = this.result;\n        if (cursor) {\n            console.log(cursor.value.userName);\n            cursor.continue();\n        } else {\n            console.log('检索结束');\n        }\n    })\n});\n")),Object(r.b)("p",null,"在上面的代码中如果检索到符合条件的数据时,我们可以:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"使用cursor.value拿到数据."),Object(r.b)("li",{parentName:"ul"},"使用cursor.updata()更新数据."),Object(r.b)("li",{parentName:"ul"},"使用cursor.delete()删除数据."),Object(r.b)("li",{parentName:"ul"},"使用cursor.continue()读取下一条数据.")),Object(r.b)("h2",{id:"索引"},"索引"),Object(r.b)("p",null,"在上面代码中我们获取数据都是用的主键。但是在很多情况下我们并不知道我们需要数据的主键是什么。我们知道一个大概的条件，比如说年龄大于20岁的用户。这个时候我们就需要用到索引，以便有条件的查找。"),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"创建索引")),Object(r.b)("p",null,"我们使用对象仓库的createIndex()方法来创建一个索引."),Object(r.b)("p",null,"createIndex(\nname: string,\nkeyPath: string | string[],\noptionalParameters?: IDBIndexParameters)\n: IDBIndex;"),Object(r.b)("p",null,"createIndex()方法接收三个参数:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"name：索引名,不能重复."),Object(r.b)("li",{parentName:"ul"},"keyPath：你要在存储对象上的那个属性上建立索引,可以是一个单个的key值,也可以是一个包含key值集合的数组."),Object(r.b)("li",{parentName:"ul"},"optionalParameters：一个可选的对象参数{unique, multiEntry}",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"unique: 用来指定索引值是否可以重复,为true代表不能相同,为false时代表可以相同"),Object(r.b)("li",{parentName:"ul"},"multiEntry: 当第二个参数keyPath为一个数组时.如果multiEntry是true,则会以数组中的每个元素建立一条索引.如果是false,则以整个数组为keyPath值,添加一条索引.")))),Object(r.b)("p",null,"下面让我们来看一个完整的例子,我们建立一条用户年龄的索引."),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{className:"language-js"}),"const request = indexedDB.open('myDatabase', 5);\nrequest.addEventListener('upgradeneeded', e => {\n    const db = e.target.result;\n    const store = db.createObjectStore('Users', {\n        keyPath: 'userId',\n        autoIncrement: false\n    });\n    const idx = store.createIndex('ageIndex', 'age', {\n        unique: false\n    })\n});\n")),Object(r.b)("p",null,"这样我们就创建了一条索引."),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"使用索引")),Object(r.b)("p",null,"我们使用对象仓库上的index方法,通过传入一个索引名.来拿到一个索引对象："),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{className:"language-js"}),"const index = store.index('ageIndex');\n")),Object(r.b)("p",null,"然后我们就可以使用这个索引了.比如说我们要拿到年龄在20岁以上的数据,升序排列."),Object(r.b)("pre",null,Object(r.b)("code",a({parentName:"pre"},{className:"language-js"}),"const request = indexedDB.open('myDatabase', 4);\nrequest.addEventListener('success', e => {\n    const db = e.target.result;\n    const tx = db.transaction('Users', 'readwrite');\n    const store = tx.objectStore('Users');\n    const index = store.index('ageIndex');\n    const req = index.openCursor(IDBKeyRange.lowerBound(20), 'next');\n    req.addEventListener('success', e => {\n        const cursor = e.target.result;\n        if (cursor) {\n            console.log(cursor.value.age);\n            cursor.continue();\n        } else {\n            console.log('检索结束');\n        }\n    })\n});\n")))}o.isMDXComponent=!0},277:function(e,n,t){"use strict";t.d(n,"a",(function(){return s})),t.d(n,"b",(function(){return d}));var r=t(0),a=t.n(r),l=a.a.createContext({}),c=function(e){var n=a.a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):Object.assign({},n,e)),t},s=function(e){var n=c(e.components);return a.a.createElement(l.Provider,{value:n},e.children)};var b="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.a.createElement(a.a.Fragment,{},n)}},o=Object(r.forwardRef)((function(e,n){var t=e.components,r=e.mdxType,l=e.originalType,s=e.parentName,b=function(e,n){var t={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&-1===n.indexOf(r)&&(t[r]=e[r]);return t}(e,["components","mdxType","originalType","parentName"]),o=c(t),d=r,p=o[s+"."+d]||o[d]||u[d]||l;return t?a.a.createElement(p,Object.assign({},{ref:n},b,{components:t})):a.a.createElement(p,Object.assign({},{ref:n},b))}));function d(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var l=t.length,c=new Array(l);c[0]=o;var s={};for(var u in n)hasOwnProperty.call(n,u)&&(s[u]=n[u]);s.originalType=e,s[b]="string"==typeof e?e:r,c[1]=s;for(var d=2;d<l;d++)c[d]=t[d];return a.a.createElement.apply(null,c)}return a.a.createElement.apply(null,t)}o.displayName="MDXCreateElement"}}]);