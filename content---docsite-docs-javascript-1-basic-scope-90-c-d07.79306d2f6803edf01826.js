(window.webpackJsonp=window.webpackJsonp||[]).push([[48],{222:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return i})),t.d(n,"rightToc",(function(){return c})),t.d(n,"default",(function(){return p}));t(0);var l=t(396);function a(){return(a=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var l in t)Object.prototype.hasOwnProperty.call(t,l)&&(e[l]=t[l])}return e}).apply(this,arguments)}function b(e,n){if(null==e)return{};var t,l,a=function(e,n){if(null==e)return{};var t,l,a={},b=Object.keys(e);for(l=0;l<b.length;l++)t=b[l],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var b=Object.getOwnPropertySymbols(e);for(l=0;l<b.length;l++)t=b[l],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var i={title:"作用域",sidebar_label:"作用域"},c=[{value:"块级作用域",id:"块级作用域",children:[]},{value:"let 不存在变量提升",id:"let-不存在变量提升",children:[{value:"var 声明的「创建、初始化和赋值」过程",id:"var-声明的「创建、初始化和赋值」过程",children:[]},{value:"function 声明的「创建、初始化和赋值」过程",id:"function-声明的「创建、初始化和赋值」过程",children:[]},{value:"let 声明的「创建、初始化和赋值」过程",id:"let-声明的「创建、初始化和赋值」过程",children:[]}]},{value:"暂时性死区",id:"暂时性死区",children:[]},{value:"更多阅读",id:"更多阅读",children:[]}],r={rightToc:c},o="wrapper";function p(e){var n=e.components,t=b(e,["components"]);return Object(l.b)(o,a({},r,t,{components:n,mdxType:"MDXLayout"}),Object(l.b)("p",null,"Scope指变量的",Object(l.b)("strong",{parentName:"p"},"可见性"),"。"),Object(l.b)("pre",null,Object(l.b)("code",a({parentName:"pre"},{className:"language-js"}),"// Example #1\nvar color = 'red';\nfunction test() {\n  return color;\n}\nconsole.log(test()); // red\n")),Object(l.b)("pre",null,Object(l.b)("code",a({parentName:"pre"},{className:"language-js"}),"// Example #2\nfunction test() {\n  var color = 'red';\n}\ntest()\nconsole.log(color); // undefined\n")),Object(l.b)("pre",null,Object(l.b)("code",a({parentName:"pre"},{className:"language-js"}),"// Example #3\nfunction test() {\n  var color = 'red';\n  return color;\n}\nconsole.log(test()); // red\n")),Object(l.b)("p",null,"在解析阶段构建的作用域其实就是",Object(l.b)("strong",{parentName:"p"},"定义了一套变量查找(即变量可见性)的规则"),"。请注意这里说的是一套规则，有没有找到，没有找到报 ",Object(l.b)("inlineCode",{parentName:"p"},"ReferenceError")," 的错都不是解析器的事情："),Object(l.b)("img",{width:"400",src:"https://cosmos-x.oss-cn-hangzhou.aliyuncs.com/V0UPNK.jpg"}),Object(l.b)("p",null,"作用域链是指变量查找的顺序，先去哪里找，再去哪里找，就像一根链条以下从下往上找。"),Object(l.b)("h2",{id:"块级作用域"},"块级作用域"),Object(l.b)("p",null,"变量声明：\nES5 只有全局作用域和函数作用域，没有块级作用域，导致了以下的不合理场景出现："),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"由于变量提升，内层变量可能会覆盖外层变量"),Object(l.b)("li",{parentName:"ul"},"用来计数的循环变量泄露为全局变量")),Object(l.b)("p",null,"ES6中 let 的出现实际上为 JavaScript 新增了块级作用域，在语句块中声明的语句或变量只在当前语句块中起作用。"),Object(l.b)("pre",null,Object(l.b)("code",a({parentName:"pre"},{className:"language-js"}),"function f1() {\n  let n = 5;\n  if (true) {\n    let n = 10;\n  }\n  console.log(n); // 5\n}\n")),Object(l.b)("p",null,"上面的函数有两个代码块，都声明了变量n，运行后输出 5。这表示外层代码块不受内层代码块的影响。如果两次都使用var定义变量n，最后输出的值才是 10。ES6 允许块级作用域的任意嵌套，每一层都是一个单独的作用域。外层作用域无法读取内层作用域的内部变量。"),Object(l.b)("p",null,"函数声明：\nES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明；\nES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。"),Object(l.b)("blockquote",null,Object(l.b)("p",{parentName:"blockquote"},Object(l.b)("strong",{parentName:"p"},"注意")),Object(l.b)("p",{parentName:"blockquote"},"由于要兼容老的代码，ES6 在附录 B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。"),Object(l.b)("ul",{parentName:"blockquote"},Object(l.b)("li",{parentName:"ul"},"允许在块级作用域内声明函数。"),Object(l.b)("li",{parentName:"ul"},"函数声明类似于var，即会提升到全局作用域或函数作用域的头部。"),Object(l.b)("li",{parentName:"ul"},"同时，函数声明还会提升到所在的块级作用域的头部。"))),Object(l.b)("p",null,"上面三条规则只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。根据这三条规则，浏览器的 ES6 环境中，块级作用域内声明的函数，行为类似于var声明的变量。"),Object(l.b)("p",null,"ES6 新增了 ",Object(l.b)("inlineCode",{parentName:"p"},"let")," 命令，用来声明变量。它的用法类似于 ",Object(l.b)("inlineCode",{parentName:"p"},"var")," ，但是所声明的变量，只在 ",Object(l.b)("inlineCode",{parentName:"p"},"let")," 命令所在的代码块内有效，如下图所示："),Object(l.b)("img",{src:"https://cosmos-x.oss-cn-hangzhou.aliyuncs.com/NecK56.png"}),Object(l.b)("p",null,"从下面两个例子看看，在 ",Object(l.b)("inlineCode",{parentName:"p"},"for")," 循环中使用 ",Object(l.b)("inlineCode",{parentName:"p"},"var")," 和 ",Object(l.b)("inlineCode",{parentName:"p"},"let")," 的区别："),Object(l.b)("pre",null,Object(l.b)("code",a({parentName:"pre"},{className:"language-js"}),"var a = [];\nfor (var i = 0; i < 10; i++) {\n  a[i] = function () {\n    console.log(i);\n  };\n}\na[6](); // 10\n")),Object(l.b)("p",null,"上面代码中，变量 ",Object(l.b)("inlineCode",{parentName:"p"},"i")," 是 ",Object(l.b)("inlineCode",{parentName:"p"},"var")," 命令声明的，在",Object(l.b)("strong",{parentName:"p"},"全局范围"),"内都有效，所以全局只有一个变量 ",Object(l.b)("inlineCode",{parentName:"p"},"i")," 。每一次循环，变量i的值都会发生改变，而数组 a 的函数内部的 ",Object(l.b)("inlineCode",{parentName:"p"},"console.log(i)")," ，里面的 ",Object(l.b)("inlineCode",{parentName:"p"},"i")," 指向的就是全局的 ",Object(l.b)("inlineCode",{parentName:"p"},"i")," 。也就是说，所有数组 a 的成员里面的 ",Object(l.b)("inlineCode",{parentName:"p"},"i")," ，指向的都是同一个 ",Object(l.b)("inlineCode",{parentName:"p"},"i")," ，导致运行时输出的是",Object(l.b)("strong",{parentName:"p"},"最后一轮"),"的 ",Object(l.b)("inlineCode",{parentName:"p"},"i")," 的值，也就是 ",Object(l.b)("inlineCode",{parentName:"p"},"10")," 。"),Object(l.b)("pre",null,Object(l.b)("code",a({parentName:"pre"},{className:"language-js"}),"var a = [];\nfor (let i = 0; i < 10; i++) {\n  a[i] = function () {\n    console.log(i);\n  };\n}\na[6](); // 6\n")),Object(l.b)("p",null,"上面代码中，变量 ",Object(l.b)("inlineCode",{parentName:"p"},"i")," 是 ",Object(l.b)("inlineCode",{parentName:"p"},"let")," 声明的，当前的 ",Object(l.b)("inlineCode",{parentName:"p"},"i")," 只在",Object(l.b)("strong",{parentName:"p"},"本轮循环有效"),"，所以每一次循环的 ",Object(l.b)("inlineCode",{parentName:"p"},"i")," 其实都是一个新的变量，所以最后输出的是 ",Object(l.b)("inlineCode",{parentName:"p"},"6")," 。"),Object(l.b)("h2",{id:"let-不存在变量提升"},Object(l.b)("inlineCode",{parentName:"h2"},"let")," 不存在变量提升"),Object(l.b)("p",null,"变量提升（hoisting）：通常 JS 引擎会在正式执行之前先进行一次预编译，在这个过程中，首先将变量声明及函数声明提升至当前作用域的顶端，然后进行接下来的处理。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升。"),Object(l.b)("pre",null,Object(l.b)("code",a({parentName:"pre"},{className:"language-js"}),"var liList = document.querySelectorAll('li') // 共5个li\nfor (var i = 0; i < liList.length; i++) {\n  liList[i].onclick = function() {\n    console.log(i)\n  }\n}\n")),Object(l.b)("p",null,"根据以上代码可知，如果依次点击 ",Object(l.b)("inlineCode",{parentName:"p"},"li")," ，会打印出 5 个 5 。因为代码中只通过 ",Object(l.b)("inlineCode",{parentName:"p"},"var")," 声明了一个 ",Object(l.b)("inlineCode",{parentName:"p"},"i")," ，在循环之后 ",Object(l.b)("inlineCode",{parentName:"p"},"i")," 变为 5 。"),Object(l.b)("pre",null,Object(l.b)("code",a({parentName:"pre"},{className:"language-js"}),"var liList = document.querySelectorAll('li') // 共5个li\nfor( let i=0; i<liList.length; i++) {\n  liList[i].onclick = function() {\n    console.log(i)\n  }\n}\n")),Object(l.b)("p",null,"把代码中的 ",Object(l.b)("inlineCode",{parentName:"p"},"var")," 换成 ",Object(l.b)("inlineCode",{parentName:"p"},"let")," ，此时如果依次点击 ",Object(l.b)("inlineCode",{parentName:"p"},"li")," ，会依次打印出 ",Object(l.b)("inlineCode",{parentName:"p"},"0、1、2、3、4"),"。"),Object(l.b)("p",null,"此时，代码中也只声明了一个 ",Object(l.b)("inlineCode",{parentName:"p"},"i")," ，但是打印出了不同的值。这是为什么呢，我们可以把上面一段代码近似地理解为如下形式："),Object(l.b)("pre",null,Object(l.b)("code",a({parentName:"pre"},{className:"language-js"}),"var liList = document.querySelectorAll('li') // 共5个li\nfor (let i = 0; i < liList.length; i++) {\n  let i = 隐藏作用域中的i // 敲黑板，此处很重要！\n  liList[i].onclick = function() {\n    console.log(i)\n  }\n}\n")),Object(l.b)("p",null,"通过如上代码，我们知道通过五次循环，产生了 ",Object(l.b)("inlineCode",{parentName:"p"},"5")," 个不同的 ",Object(l.b)("inlineCode",{parentName:"p"},"i")," ，所以 ",Object(l.b)("inlineCode",{parentName:"p"},"console.log(i)")," ，打印出的值各不相同。"),Object(l.b)("h3",{id:"var-声明的「创建、初始化和赋值」过程"},Object(l.b)("inlineCode",{parentName:"h3"},"var")," 声明的「创建、初始化和赋值」过程"),Object(l.b)("pre",null,Object(l.b)("code",a({parentName:"pre"},{className:"language-js"}),"function fn(){\n  var x = 1\n  var y = 2\n}\nfn()\n")),Object(l.b)("p",null,"在执行 ",Object(l.b)("inlineCode",{parentName:"p"},"fn")," 时，会有以下过程（不完全）："),Object(l.b)("ol",null,Object(l.b)("li",{parentName:"ol"},"进入 ",Object(l.b)("inlineCode",{parentName:"li"},"fn")," ，为 ",Object(l.b)("inlineCode",{parentName:"li"},"fn")," 创建一个环境。"),Object(l.b)("li",{parentName:"ol"},"找到 ",Object(l.b)("inlineCode",{parentName:"li"},"fn")," 中所有用 ",Object(l.b)("inlineCode",{parentName:"li"},"var")," 声明的变量，在这个环境中「创建」这些变量（即 x 和 y）。"),Object(l.b)("li",{parentName:"ol"},"将这些变量「初始化」为 ",Object(l.b)("inlineCode",{parentName:"li"},"undefined")," 。"),Object(l.b)("li",{parentName:"ol"},"开始执行代码"),Object(l.b)("li",{parentName:"ol"},Object(l.b)("inlineCode",{parentName:"li"},"x = 1")," 将 ",Object(l.b)("inlineCode",{parentName:"li"},"x")," 变量「赋值」为 1"),Object(l.b)("li",{parentName:"ol"},Object(l.b)("inlineCode",{parentName:"li"},"y = 2")," 将 ",Object(l.b)("inlineCode",{parentName:"li"},"y")," 变量「赋值」为 2")),Object(l.b)("p",null,"也就是说 ",Object(l.b)("inlineCode",{parentName:"p"},"var")," 声明会在代码执行之前就将创建变量，并将其初始化为 ",Object(l.b)("inlineCode",{parentName:"p"},"undefined")," 。\n这就解释了为什么在 ",Object(l.b)("inlineCode",{parentName:"p"},"var x = 1")," 之前 ",Object(l.b)("inlineCode",{parentName:"p"},"console.log(x)")," 会得到 ",Object(l.b)("inlineCode",{parentName:"p"},"undefined")," 。"),Object(l.b)("h3",{id:"function-声明的「创建、初始化和赋值」过程"},Object(l.b)("inlineCode",{parentName:"h3"},"function")," 声明的「创建、初始化和赋值」过程"),Object(l.b)("pre",null,Object(l.b)("code",a({parentName:"pre"},{className:"language-js"}),"fn2()\n\nfunction fn2(){\n  console.log(2)\n}\n")),Object(l.b)("p",null,"JS 引擎会有以下过程："),Object(l.b)("ol",null,Object(l.b)("li",{parentName:"ol"},"找到所有用 ",Object(l.b)("inlineCode",{parentName:"li"},"function")," 声明的变量，在环境中「创建」这些变量。"),Object(l.b)("li",{parentName:"ol"},"将这些变量「初始化」并「赋值」为 ",Object(l.b)("inlineCode",{parentName:"li"},"function(){ console.log(2) }")," 。"),Object(l.b)("li",{parentName:"ol"},"开始执行代码 ",Object(l.b)("inlineCode",{parentName:"li"},"fn2()")," 。")),Object(l.b)("p",null,"也就是说 ",Object(l.b)("inlineCode",{parentName:"p"},"function")," 声明会在代码执行之前就「创建、初始化并赋值」。"),Object(l.b)("h3",{id:"let-声明的「创建、初始化和赋值」过程"},Object(l.b)("inlineCode",{parentName:"h3"},"let")," 声明的「创建、初始化和赋值」过程"),Object(l.b)("pre",null,Object(l.b)("code",a({parentName:"pre"},{className:"language-js"}),"{\n  let x = 1\n  x = 2\n}\n")),Object(l.b)("p",null,"我们只看 ",Object(l.b)("inlineCode",{parentName:"p"},"{}")," 里面的过程："),Object(l.b)("ol",null,Object(l.b)("li",{parentName:"ol"},"找到所有用 ",Object(l.b)("inlineCode",{parentName:"li"},"let")," 声明的变量，在环境中「创建」这些变量"),Object(l.b)("li",{parentName:"ol"},"开始执行代码（注意现在还没有初始化）"),Object(l.b)("li",{parentName:"ol"},"执行 ",Object(l.b)("inlineCode",{parentName:"li"},"x = 1")," ，将 ",Object(l.b)("inlineCode",{parentName:"li"},"x")," 「初始化」为 1（这并不是一次赋值，如果代码是 ",Object(l.b)("inlineCode",{parentName:"li"},"let x")," ，就将 ",Object(l.b)("inlineCode",{parentName:"li"},"x")," 初始化为 ",Object(l.b)("inlineCode",{parentName:"li"},"undefined")," ）"),Object(l.b)("li",{parentName:"ol"},"执行 ",Object(l.b)("inlineCode",{parentName:"li"},"x = 2")," ，对 ",Object(l.b)("inlineCode",{parentName:"li"},"x")," 进行「赋值」")),Object(l.b)("p",null,"这就解释了为什么在 ",Object(l.b)("inlineCode",{parentName:"p"},"let x")," 之前使用 ",Object(l.b)("inlineCode",{parentName:"p"},"x")," 会报错："),Object(l.b)("pre",null,Object(l.b)("code",a({parentName:"pre"},{className:"language-js"}),"let x = 'global'\n{\n  console.log(x) // Uncaught ReferenceError: x is not defined\n  let x = 1\n}\n")),Object(l.b)("p",null,"原因有两个："),Object(l.b)("ol",null,Object(l.b)("li",{parentName:"ol"},Object(l.b)("inlineCode",{parentName:"li"},"console.log(x)")," 中的 x 指的是下面的 x，而不是全局的 x"),Object(l.b)("li",{parentName:"ol"},"执行 log 时 x 还没「初始化」，所以不能使用（也就是所谓的暂时死区）")),Object(l.b)("p",null,"看到这里，你应该明白了 ",Object(l.b)("inlineCode",{parentName:"p"},"let")," 到底有没有提升："),Object(l.b)("ol",null,Object(l.b)("li",{parentName:"ol"},Object(l.b)("inlineCode",{parentName:"li"},"let")," 的「创建」过程被提升了，但是初始化没有提升。"),Object(l.b)("li",{parentName:"ol"},Object(l.b)("inlineCode",{parentName:"li"},"var")," 的「创建」和「初始化」都被提升了。"),Object(l.b)("li",{parentName:"ol"},"function 的「创建」「初始化」和「赋值」都被提升了。")),Object(l.b)("p",null,"这四种声明，用下图就可以快速理解："),Object(l.b)("img",{src:"https://cosmos-x.oss-cn-hangzhou.aliyuncs.com/hwksuH.jpg"}),Object(l.b)("p",null,"下面来看一个有趣的例子："),Object(l.b)("img",{src:"https://cosmos-x.oss-cn-hangzhou.aliyuncs.com/wZTieV.jpg"}),Object(l.b)("p",null,"从图上这一系列操作可以看出，如果 ",Object(l.b)("inlineCode",{parentName:"p"},"let x")," 的初始化过程失败了，会导致："),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"x")," 变量就将永远处于 created 状态。"),Object(l.b)("li",{parentName:"ul"},"无法再次对 ",Object(l.b)("inlineCode",{parentName:"li"},"x")," 进行初始化（初始化只有一次机会，而那次机会你失败了）"),Object(l.b)("li",{parentName:"ul"},"无法再次对 ",Object(l.b)("inlineCode",{parentName:"li"},"x")," 进行赋值（毕竟初始化都失败了，肯定不能继续赋值了）"),Object(l.b)("li",{parentName:"ul"},"由于 ",Object(l.b)("inlineCode",{parentName:"li"},"x")," 无法被初始化，所以 ",Object(l.b)("inlineCode",{parentName:"li"},"x")," 永远处在暂时死区")),Object(l.b)("h2",{id:"暂时性死区"},"暂时性死区"),Object(l.b)("p",null,"暂时性死区(Temporal Dead Zone，简称 ",Object(l.b)("strong",{parentName:"p"},"TDZ"),")：在代码块内，使用 ",Object(l.b)("inlineCode",{parentName:"p"},"let")," 命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”。"),Object(l.b)("p",null,"“暂时性死区”也意味着 ",Object(l.b)("inlineCode",{parentName:"p"},"typeof")," 不再是一个百分之百安全的操作："),Object(l.b)("pre",null,Object(l.b)("code",a({parentName:"pre"},{className:"language-js"}),"typeof x; // ReferenceError\nlet x;\n")),Object(l.b)("p",null,"上面代码中，变量 ",Object(l.b)("inlineCode",{parentName:"p"},"x")," 使用 ",Object(l.b)("inlineCode",{parentName:"p"},"let")," 命令声明，所以在声明之前，都属于 ",Object(l.b)("inlineCode",{parentName:"p"},"x")," 的“死区”，只要用到该变量就会报错。因此， ",Object(l.b)("inlineCode",{parentName:"p"},"typeof")," 运行时就会抛出一个 ",Object(l.b)("inlineCode",{parentName:"p"},"ReferenceError")," 。"),Object(l.b)("p",null,"再看下面这个例子："),Object(l.b)("pre",null,Object(l.b)("code",a({parentName:"pre"},{className:"language-js"}),"// let x; x未声明\ntypeof x; // undefined\n")),Object(l.b)("p",null,"从上面的代码中我们可以看到，对一个根本没有声明的变量却返回了 ",Object(l.b)("inlineCode",{parentName:"p"},"undefined")," 。在没有 ",Object(l.b)("inlineCode",{parentName:"p"},"let")," 之前， ",Object(l.b)("inlineCode",{parentName:"p"},"typeof")," 运算符是百分之百安全的，永远不会报错。现在这一点不成立了，所以在以后的代码中一定要注意。"),Object(l.b)("p",null,"总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。"),Object(l.b)("h2",{id:"更多阅读"},"更多阅读"),Object(l.b)("ol",null,Object(l.b)("li",{parentName:"ol"},Object(l.b)("a",a({parentName:"li"},{href:"https://zhuanlan.zhihu.com/p/28140450l"}),"块级作用域，暂时性死区等"))))}p.isMDXComponent=!0},396:function(e,n,t){"use strict";t.d(n,"a",(function(){return c})),t.d(n,"b",(function(){return j}));var l=t(0),a=t.n(l),b=a.a.createContext({}),i=function(e){var n=a.a.useContext(b),t=n;return e&&(t="function"==typeof e?e(n):Object.assign({},n,e)),t},c=function(e){var n=i(e.components);return a.a.createElement(b.Provider,{value:n},e.children)};var r="mdxType",o={inlineCode:"code",wrapper:function(e){var n=e.children;return a.a.createElement(a.a.Fragment,{},n)}},p=Object(l.forwardRef)((function(e,n){var t=e.components,l=e.mdxType,b=e.originalType,c=e.parentName,r=function(e,n){var t={};for(var l in e)Object.prototype.hasOwnProperty.call(e,l)&&-1===n.indexOf(l)&&(t[l]=e[l]);return t}(e,["components","mdxType","originalType","parentName"]),p=i(t),j=l,O=p[c+"."+j]||p[j]||o[j]||b;return t?a.a.createElement(O,Object.assign({},{ref:n},r,{components:t})):a.a.createElement(O,Object.assign({},{ref:n},r))}));function j(e,n){var t=arguments,l=n&&n.mdxType;if("string"==typeof e||l){var b=t.length,i=new Array(b);i[0]=p;var c={};for(var o in n)hasOwnProperty.call(n,o)&&(c[o]=n[o]);c.originalType=e,c[r]="string"==typeof e?e:l,i[1]=c;for(var j=2;j<b;j++)i[j]=t[j];return a.a.createElement.apply(null,i)}return a.a.createElement.apply(null,t)}p.displayName="MDXCreateElement"}}]);