(window.webpackJsonp=window.webpackJsonp||[]).push([[82],{184:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return l})),t.d(n,"rightToc",(function(){return b})),t.d(n,"default",(function(){return i}));t(0);var a=t(396);function r(){return(r=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e}).apply(this,arguments)}function c(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},c=Object.keys(e);for(a=0;a<c.length;a++)t=c[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var c=Object.getOwnPropertySymbols(e);for(a=0;a<c.length;a++)t=c[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l={title:"async/await",sidebar_label:"async/await"},b=[{value:"前言",id:"前言",children:[{value:"async—声明一个异步函数",id:"async声明一个异步函数",children:[]},{value:"await—暂停异步的功能执行",id:"await暂停异步的功能执行",children:[]}]},{value:"语法：",id:"语法：",children:[]},{value:"容错：",id:"容错：",children:[{value:"方法一：try…catch",id:"方法一：trycatch",children:[]},{value:"方法二：使用.catch",id:"方法二：使用catch",children:[]},{value:"方法三：让函数返回两个值",id:"方法三：让函数返回两个值",children:[]},{value:"性能",id:"性能",children:[]}]},{value:"async...await优点",id:"asyncawait优点",children:[{value:"优点一：更可读的串行代码",id:"优点一：更可读的串行代码",children:[]}]}],o={rightToc:b},s="wrapper";function i(e){var n=e.components,t=c(e,["components"]);return Object(a.b)(s,r({},o,t,{components:n,mdxType:"MDXLayout"}),Object(a.b)("h2",{id:"前言"},"前言"),Object(a.b)("p",null,"async/await建立在Promises上，并且与所有现有的基于Promise的API兼容。"),Object(a.b)("h3",{id:"async声明一个异步函数"},"async—声明一个异步函数"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"自动将常规函数转换成Promise，返回值也是一个Promise对象"),Object(a.b)("li",{parentName:"ul"},"只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数")),Object(a.b)("h3",{id:"await暂停异步的功能执行"},"await—暂停异步的功能执行"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"放置在Promise调用之前，await强制其他代码等待，直到Promise完成并返回结果"),Object(a.b)("li",{parentName:"ul"},"只能与Promise一起使用，不适用于回调async 函数的几种使用形式")),Object(a.b)("h2",{id:"语法："},"语法："),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},"async 函数的几种使用形式")),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"// 函数表达式\nconst foo = async function () {}\n\n// 对象方法\nconst obj = { async foo () {} }\nobj.foo().then(() => {console.log('balabala')})\n\n// 箭头函数\nconst foo = async () => {}\n\n// class 方法\nclass Storage {\n constructor () {\n   this.cachePromise = caches.open('avatars')\n }\n async getAvatar (name) {\n   const cache = await this.cachePromise\n   return cache.match(`/avatars/${name}.jpg/`)\n }\n}\n\nconst storage = new Storage()\nstorgae.getAvatar('jack').then(...)\n")),Object(a.b)("p",null,"2、await的使用规则："),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"await后需要的是一个Promise对象，如果不是则会被转成Promise对象。"),Object(a.b)("li",{parentName:"ul"},"如果存在一个await后的Promise转为rejected状态，那么整个async函数都会中断操作。"),Object(a.b)("li",{parentName:"ul"},"如果状态是resolve，那么他的返回值则会变成then里面的参数，如下：")),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"async function f () {\n return await 123;\n}\n\nf().then(v => console.log(v)) // 123\n")),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"注意：")),Object(a.b)("p",null,Object(a.b)("em",{parentName:"p"},"容错：")," 由于await后面的promise运行结果可能是rejected，最好把await放入try-catch中"),Object(a.b)("p",null,Object(a.b)("em",{parentName:"p"},"性能：")," await后的异步操作，如果彼此没有依赖关系最好同时触发，在下面会有介绍"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("strong",{parentName:"li"},"只能在async函数内部使用，如果在普通函数中，会报错"))),Object(a.b)("p",null,"async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。"),Object(a.b)("h2",{id:"容错："},"容错："),Object(a.b)("p",null,"之前也谈到了Promise对错误处理的一些局限性，这里主要看看 await/asyc 对错误处理要注意的一些问题。"),Object(a.b)("h3",{id:"方法一：trycatch"},"方法一：try…catch"),Object(a.b)("p",null,"最标准的方法是使用 try…catch 语句。在调用 await 函数时，如果出现非正常状况就会跑出异常。"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"class BookModel {\n fetchAll() {\n   return new Promise((resolve, reject) => {\n     window.setTimeout(() => { reject({'error': 400}) }, 1000);\n   });\n }\n}\n// async/await\nasync getBooksByAuthorWithAwait(authorId) {\ntry {\n const books = await bookModel.fetchAll();\n} catch (error) {\n console.log(error);    // { \"error\": 400 }\n}\n")),Object(a.b)("p",null,"在捕捉到异常之后，在catch根据需要有几种方法来处理它："),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("strong",{parentName:"li"},"直接处理异常"),"，并返回一个正常值。（不在 catch 块中使用任何 return 语句相当于使用 return undefined，undefined 也是一个正常值。）"),Object(a.b)("li",{parentName:"ul"},Object(a.b)("strong",{parentName:"li"},"抛出异常"),"，如果你想让调用者来处理它，就将它抛出。可以直接抛出错误对象",Object(a.b)("ul",{parentName:"li"},Object(a.b)("li",{parentName:"ul"},Object(a.b)("strong",{parentName:"li"},"直接抛出"),"：比如 throw error，这样就可以在 promise 链中使用 await getBooksByAuthorWithAwait() 函数（也就是像 getBooksByAuthorWithAwait().then(...).catch(error => …) 这样调用它）。"),Object(a.b)("li",{parentName:"ul"},Object(a.b)("strong",{parentName:"li"},"加工一下再抛出"),"：包装成 Error 对象，比如 throw new Error(error)，那么在控制台中显示这个错误时它将给出完整的堆栈跟踪信息。"))),Object(a.b)("li",{parentName:"ul"},Object(a.b)("strong",{parentName:"li"},"拒绝它"),"，比如 return Promise.reject(error)。这相当于 throw error，因此不推荐使用。")),Object(a.b)("p",null,"这种方法也有一个缺陷。"),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},"由于 try...catch 会捕获代码块中的每个异常，所以通常不会被 promise 捕获的异常也会被捕获到。比如：")),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"class BookModel {\n fetchAll() {\n   cb();    // note `cb` is undefined and will result an exception\n   return fetch('/books');\n }\n}\ntry {\n bookModel.fetchAll();\n} catch(error) {\n console.log(error);  // This will print \"cb is not defined\"\n}\n")),Object(a.b)("p",null,"运行此代码，你将会在控制台看到“ReferenceError：cb is not defined”错误，消息的颜色是黑色的。错误消息是通过 console.log() 输出的，而不是 JavaScript 本身。有时候这可能是致命的：如果 BookModel 被包含在一系列函数调用中，并且其中一个调用把错误吞噬掉了，那么找到这样的 undefined 错误将非常困难。"),Object(a.b)("ol",{start:2},Object(a.b)("li",{parentName:"ol"},"如果是多个异步请求且每个请求的错误处理逻辑是不一样的，将他们都包裹成一个try-catch显然是不行的，如果为它们写多个不同的try-catch，代码会显得很冗余。可以试试下面介绍的两种方法。")),Object(a.b)("h3",{id:"方法二：使用catch"},"方法二：使用.catch"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"let books = await fetchData()\n .catch((error) => { console.log(error); }); // return undefined if error happens\n")),Object(a.b)("p",null,"注意：在catch里面不要直接将error返回，如果 fetchData 返回 resolve 正确结果时，data 是我们要的结果，如果是 reject 了，发生错误了，那么 data 是error，这不是我们想要的，可以返回undefined。"),Object(a.b)("p",null,"这种方法有两个小问题："),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"它是和 promise 的混合体。你仍然需要了解 promise 的工作原理才能看懂这段代码。"),Object(a.b)("li",{parentName:"ul"},"错误处理出现在普通代码逻辑之中，这样不直观。")),Object(a.b)("h3",{id:"方法三：让函数返回两个值"},"方法三：让函数返回两个值"),Object(a.b)("p",null,"错误处理的另一种方式是受到了 Go 语言启发，它允许异步函数返回错误和结果，这样即可使error和data分为两个变量，更加明确："),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"// 抽离成公共方法\nconst awaitWrap = promise => {\n return promise\n          .then(data => [null, data])\n          .catch(err => [err, null])\n}\n\nconst [err, data] = await awaitWrap(fetchData);\n")),Object(a.b)("h3",{id:"性能"},"性能"),Object(a.b)("p",null,"await语法糖明显的缺点，就是多个异步代码不经过特别优化会很容易“串行化”，想要避免这样低效的代码，又要写一些“恶心”的不太容易阅读的代码去优化它。"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"\na(() => {\n a1();\n});\n\nb(() => {\n b1();\n});\n")),Object(a.b)("p",null,"如果写成下面的方式，虽然一定能保证功能一致，但变成了最低效的执行方式："),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"await a();\nawait a1();\nawait b();\nawait b1();\n")),Object(a.b)("p",null,"因为翻译成回调，就变成了："),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"a(() => {\n a1(() => {\n   b(() => {\n     b1();\n   });\n });\n});\n")),Object(a.b)("p",null,"然而我们发现，原始代码中，函数 b 可以与 a 同时执行，但 async/await 语法会让我们倾向于在 a1 执行完后，再执行 b。所以当我们意识到这一点，可以优化一下性能："),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"const resA = a();\nconst resB = b();  // 先让a和b两个异步请求同时发送出去\nawait resA;\na1();\nawait resB;\nb1(); // b1的执行依赖了a要先完成，这是不好的\n")),Object(a.b)("p",null,"但其实这个逻辑也无法达到回调的效果，虽然 a 与 b 同时执行了，但 b1 原本只要等待 b 执行完，现在如果 a 执行时间比 b 长，就变成了:"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"a(() => {\n b1();\n});\n")),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"看来只有完全隔离成两个函数：")),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"(async () => {\n await a();\n a1();\n})();\n\n(async () => {\n await b();\n b1();\n})();\n")),Object(a.b)("p",null,"或者利用 Promise.all:"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"async function A() {\n await a();\n a1();\n}\n\nasync function B() {\n await B();\n b1();\n}\n\nPromise.all([A(), B()]);\n")),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"比较常用的一个场景：同时发送多个请求都结束后才执行某个操作，且多个请求之间没有依赖关系。那就干脆就别用"),"\nasync/await:"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"Promise.all([a(), b()]).then(() => {\n a1();\n a2();\n});\n\n")),Object(a.b)("p",null,"对比 async/await 版:"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"const resA = a();\nconst resB = b();\nawait resA;\nawait resB;\na1();\na2();\n")),Object(a.b)("p",null,"回调方式这么简单的代码，换成 async/await 居然写完还要反思一下，再反推着去优化性能，这付出的代价恐怕比回调地狱还要更多。"),Object(a.b)("p",null,"而且大部分场景代码是非常复杂的，同步与 await 混杂在一起，想捋清楚其中的脉络，并正确优化性能往往是很困难的。但是我们为什么要自己挖坑再填坑呢？很多时候还会导致忘了填。"),Object(a.b)("p",null,"决定代码质量的是思维，而非框架或语法，async/await 虽好，但也要适度。"),Object(a.b)("h2",{id:"asyncawait优点"},"async...await优点"),Object(a.b)("h3",{id:"优点一：更可读的串行代码"},"优点一：更可读的串行代码"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"fetchA()\n .then(resA => fetchB(resA))\n .then(resB => fetchC(resB))\n .then(resC => fetchD(resC))\n .then(resD => ...)\n .catch(error => ...)\n")),Object(a.b)("p",null,"我们将逻辑分装在一个async函数里。这样我们就可以直接对promise使用await了，也就规避了写then回调。"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"try {\n const resA = fetchA();\n const resB = fetchB(resA);\n const resC = fetchC(resB);\n const resD = fetchD(resC);\n ...\n} catch(error) {\n ...\n}\n")),Object(a.b)("p",null,"这样比较看上去代码差不多，但是要注意，",Object(a.b)("inlineCode",{parentName:"p"},".then(resA => fetchB(resA))"),"，then里面的回调函数的处理逻辑可能更为复杂，",Object(a.b)("strong",{parentName:"p"},"而这些代码在await/async代码中将会显得很“同步”"),"，没有那么多回调函数，也没有一层层的then，代码顺序执行即可。"),Object(a.b)("p",null,"优点二：调试方便"),Object(a.b)("p",null,"在函数入口设置断点并执行跳过 await 行之后，调试器会在 ",Object(a.b)("inlineCode",{parentName:"p"},"bookModel.fetchAll()")," 执行时暂停一会儿，然后移动到下一行（也就是.filter）！这比使用 promise 要容易调试得多，因为你必须在.filter 这一行设置另一个断点。"),Object(a.b)("div",{align:"center"},Object(a.b)("img",{width:"550",src:"https://cosmos-x.oss-cn-hangzhou.aliyuncs.com/01SLkN.png"})),"优点三：返回值统一",Object(a.b)("p",null,"async关键字，尽管看起来不是很明显。它声明 ",Object(a.b)("inlineCode",{parentName:"p"},"getBooksByAuthorWithAwait()")," 函数的返回值是一个 promise，因此调用者可以安全地调用 ",Object(a.b)("inlineCode",{parentName:"p"},"getBooksByAuthorWithAwait().then(…)")," 或 ",Object(a.b)("inlineCode",{parentName:"p"},"await getBooksByAuthorWithAwait()"),"。比如像下面这段代码："),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"getBooksByAuthorWithPromise(authorId) {\n if (!authorId) {\n   return null;\n }\n return bookModel.fetchAll()\n   .then(books => books.filter(b => b.authorId === authorId));\n }\n}\n")),Object(a.b)("p",null,"在上面的代码中，",Object(a.b)("inlineCode",{parentName:"p"},"getBooksByAuthorWithPromise")," 可能返回一个 promise（正常情况）或 null（异常情况），在这种情况下，调用者无法安全地调用.then()。而如果使用 async 声明，则不会出现这种情况。"))}i.isMDXComponent=!0},396:function(e,n,t){"use strict";t.d(n,"a",(function(){return b})),t.d(n,"b",(function(){return p}));var a=t(0),r=t.n(a),c=r.a.createContext({}),l=function(e){var n=r.a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):Object.assign({},n,e)),t},b=function(e){var n=l(e.components);return r.a.createElement(c.Provider,{value:n},e.children)};var o="mdxType",s={inlineCode:"code",wrapper:function(e){var n=e.children;return r.a.createElement(r.a.Fragment,{},n)}},i=Object(a.forwardRef)((function(e,n){var t=e.components,a=e.mdxType,c=e.originalType,b=e.parentName,o=function(e,n){var t={};for(var a in e)Object.prototype.hasOwnProperty.call(e,a)&&-1===n.indexOf(a)&&(t[a]=e[a]);return t}(e,["components","mdxType","originalType","parentName"]),i=l(t),p=a,u=i[b+"."+p]||i[p]||s[p]||c;return t?r.a.createElement(u,Object.assign({},{ref:n},o,{components:t})):r.a.createElement(u,Object.assign({},{ref:n},o))}));function p(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var c=t.length,l=new Array(c);l[0]=i;var b={};for(var s in n)hasOwnProperty.call(n,s)&&(b[s]=n[s]);b.originalType=e,b[o]="string"==typeof e?e:a,l[1]=b;for(var p=2;p<c;p++)l[p]=t[p];return r.a.createElement.apply(null,l)}return r.a.createElement.apply(null,t)}i.displayName="MDXCreateElement"}}]);