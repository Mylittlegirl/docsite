(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{116:function(e,r,n){"use strict";n.r(r),n.d(r,"frontMatter",(function(){return p})),n.d(r,"rightToc",(function(){return c})),n.d(r,"default",(function(){return s}));n(0);var t=n(155);function a(){return(a=Object.assign||function(e){for(var r=1;r<arguments.length;r++){var n=arguments[r];for(var t in n)Object.prototype.hasOwnProperty.call(n,t)&&(e[t]=n[t])}return e}).apply(this,arguments)}function o(e,r){if(null==e)return{};var n,t,a=function(e,r){if(null==e)return{};var n,t,a={},o=Object.keys(e);for(t=0;t<o.length;t++)n=o[t],r.indexOf(n)>=0||(a[n]=e[n]);return a}(e,r);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(t=0;t<o.length;t++)n=o[t],r.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var p={id:"render-props",title:"Render Props",sidebar_label:"Render Props"},c=[],i={rightToc:c},l="wrapper";function s(e){var r=e.components,n=o(e,["components"]);return Object(t.b)(l,a({},i,n,{components:r,mdxType:"MDXLayout"}),Object(t.b)("p",null,"Render Props 是指一种在 React 组件之间使用一个值为函数的 prop 在 React 组件间共享代码的简单技术。"),Object(t.b)("p",null,"渲染属性指的是使用一个值为函数的prop来传递需要动态渲染的nodes或组件。如下面的代码可以看到我们的",Object(t.b)("inlineCode",{parentName:"p"},"DataProvider"),"组件包含了所有跟状态相关的代码，而",Object(t.b)("inlineCode",{parentName:"p"},"Cat"),"组件则可以是一个单纯的展示型组件，这样一来",Object(t.b)("inlineCode",{parentName:"p"},"DataProvider"),"就可以单独复用了。"),Object(t.b)("pre",null,Object(t.b)("code",a({parentName:"pre"},{className:"language-jsx"}),"import Cat from 'components/cat'\nclass DataProvider extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { target: 'Zac' };\n  }\n\n  render() {\n    return (\n      <div>\n        {this.props.render(this.state)}\n      </div>\n    )\n  }\n}\n\n<DataProvider render={data => (\n  <Cat target={data.target} />\n)}/>\n")),Object(t.b)("p",null,"虽然这个模式叫Render Props，但不是说非用一个叫render的props不可，习惯上大家更常写成下面这种："),Object(t.b)("pre",null,Object(t.b)("code",a({parentName:"pre"},{className:"language-jsx"}),"<DataProvider>\n  {data => (\n    <Cat target={data.target} />\n  )}\n</DataProvider>\n")),Object(t.b)("p",null,Object(t.b)("a",a({parentName:"p"},{href:"https://reacttraining.com/react-router/web/api/Route/Route-render-methods"}),"React Router")," 是一个典型使用 render props 的库 "),Object(t.b)("blockquote",null,Object(t.b)("p",{parentName:"blockquote"},Object(t.b)("strong",{parentName:"p"},"注意"),"：如果在 render 方法里创建函数，那么使用 render prop 会抵消使用 PureComponent 带来的优势。这是因为浅 prop 比较对于新 props 总会返回 false，并且在这种情况下每一个 render 对于 render prop 将会生成一个新的值。")),Object(t.b)("p",null,"另外这种模式，会增加我们代码的层级关系和耦合程度，不利于代码的维护。可以考虑用 Hooks 替代。"))}s.isMDXComponent=!0},155:function(e,r,n){"use strict";n.d(r,"a",(function(){return c})),n.d(r,"b",(function(){return u}));var t=n(0),a=n.n(t),o=a.a.createContext({}),p=function(e){var r=a.a.useContext(o),n=r;return e&&(n="function"==typeof e?e(r):Object.assign({},r,e)),n},c=function(e){var r=p(e.components);return a.a.createElement(o.Provider,{value:r},e.children)};var i="mdxType",l={inlineCode:"code",wrapper:function(e){var r=e.children;return a.a.createElement(a.a.Fragment,{},r)}},s=Object(t.forwardRef)((function(e,r){var n=e.components,t=e.mdxType,o=e.originalType,c=e.parentName,i=function(e,r){var n={};for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&-1===r.indexOf(t)&&(n[t]=e[t]);return n}(e,["components","mdxType","originalType","parentName"]),s=p(n),u=t,d=s[c+"."+u]||s[u]||l[u]||o;return n?a.a.createElement(d,Object.assign({},{ref:r},i,{components:n})):a.a.createElement(d,Object.assign({},{ref:r},i))}));function u(e,r){var n=arguments,t=r&&r.mdxType;if("string"==typeof e||t){var o=n.length,p=new Array(o);p[0]=s;var c={};for(var l in r)hasOwnProperty.call(r,l)&&(c[l]=r[l]);c.originalType=e,c[i]="string"==typeof e?e:t,p[1]=c;for(var u=2;u<o;u++)p[u]=n[u];return a.a.createElement.apply(null,p)}return a.a.createElement.apply(null,n)}s.displayName="MDXCreateElement"}}]);