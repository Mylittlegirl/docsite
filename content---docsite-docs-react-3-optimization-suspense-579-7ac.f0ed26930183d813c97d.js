(window.webpackJsonp=window.webpackJsonp||[]).push([[110],{148:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"rightToc",(function(){return c})),n.d(t,"default",(function(){return s}));n(0);var a=n(388);function r(){return(r=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e}).apply(this,arguments)}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var i={id:"suspense",title:"Suspense",sidebar_label:"Suspense"},c=[{value:"React.lazy",id:"reactlazy",children:[]},{value:"React.Suspense",id:"reactsuspense",children:[]}],p={rightToc:c},l="wrapper";function s(e){var t=e.components,n=o(e,["components"]);return Object(a.b)(l,r({},p,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("p",null,"Suspense lets components “wait” for something before rendering. Today, Suspense only supports one use case: ",Object(a.b)("a",r({parentName:"p"},{href:""}),"loading components dynamically with React.lazy"),". In the future, it will support other use cases like data fetching."),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"React.lazy"),Object(a.b)("li",{parentName:"ul"},"React.Suspense")),Object(a.b)("h2",{id:"reactlazy"},"React.lazy"),Object(a.b)("p",null,Object(a.b)("inlineCode",{parentName:"p"},"React.lazy()")," lets you define a component that is loaded dynamically. This helps reduce the bundle size to delay loading components that aren’t used during the initial render."),Object(a.b)("p",null,"You can learn how to use it from our ",Object(a.b)("a",r({parentName:"p"},{href:""}),"code splitting documentation"),". You might also want to check out ",Object(a.b)("a",r({parentName:"p"},{href:"https://medium.com/@pomber/lazy-loading-and-preloading-components-in-react-16-6-804de091c82d"}),"this article")," explaining how to use it in more detail."),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-jsx"}),"// This component is loaded dynamically\nconst SomeComponent = React.lazy(() => import('./SomeComponent'));\n")),Object(a.b)("p",null,"Note that rendering ",Object(a.b)("inlineCode",{parentName:"p"},"lazy")," components requires that there’s a ",Object(a.b)("inlineCode",{parentName:"p"},"<React.Suspense>")," component higher in the rendering tree. This is how you specify a loading indicator."),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},Object(a.b)("strong",{parentName:"p"},"Note"),"\nUsing React.lazywith dynamic import requires Promises to be available in the JS environment. This requires a polyfill on IE11 and below.")),Object(a.b)("h2",{id:"reactsuspense"},"React.Suspense"),Object(a.b)("p",null,Object(a.b)("inlineCode",{parentName:"p"},"React.Suspense")," let you specify the loading indicator in case some components in the tree below it are not yet ready to render. Today, lazy loading components is the only use case supported by ",Object(a.b)("inlineCode",{parentName:"p"},"<React.Suspense>"),":"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-jsx"}),"// This component is loaded dynamically\nconst OtherComponent = React.lazy(() => import('./OtherComponent'));\n\nfunction MyComponent() {\n  return (\n    // Displays <Spinner> until OtherComponent loads\n    <React.Suspense fallback={<Spinner />}>\n      <div>\n        <OtherComponent />\n      </div>\n    </React.Suspense>\n  );\n}\n")),Object(a.b)("p",null,"It is documented in our ",Object(a.b)("a",r({parentName:"p"},{href:""}),"code splitting guide"),". Note that ",Object(a.b)("inlineCode",{parentName:"p"},"lazy")," components can be deep inside the ",Object(a.b)("inlineCode",{parentName:"p"},"Suspense")," tree — it doesn’t have to wrap every one of them. The best practice is to place ",Object(a.b)("inlineCode",{parentName:"p"},"<Suspense>")," where you want to see a loading indicator, but to use lazy() wherever you want to do code splitting."),Object(a.b)("p",null,"While this is not supported today, in the future we plan to let ",Object(a.b)("inlineCode",{parentName:"p"},"Suspense")," handle more scenarios such as data fetching. You can read about this in ",Object(a.b)("a",r({parentName:"p"},{href:"https://reactjs.org/blog/2018/11/27/react-16-roadmap.html"}),"our roadmap"),"."),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},Object(a.b)("strong",{parentName:"p"},"Note"),"\n",Object(a.b)("inlineCode",{parentName:"p"},"React.lazy()")," and ",Object(a.b)("inlineCode",{parentName:"p"},"<React.Suspense>")," are not yet supported by ",Object(a.b)("inlineCode",{parentName:"p"},"ReactDOMServer"),". This is a known limitation that will be resolved in the future.")))}s.isMDXComponent=!0},388:function(e,t,n){"use strict";n.d(t,"a",(function(){return c})),n.d(t,"b",(function(){return u}));var a=n(0),r=n.n(a),o=r.a.createContext({}),i=function(e){var t=r.a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):Object.assign({},t,e)),n},c=function(e){var t=i(e.components);return r.a.createElement(o.Provider,{value:t},e.children)};var p="mdxType",l={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},s=Object(a.forwardRef)((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,c=e.parentName,p=function(e,t){var n={};for(var a in e)Object.prototype.hasOwnProperty.call(e,a)&&-1===t.indexOf(a)&&(n[a]=e[a]);return n}(e,["components","mdxType","originalType","parentName"]),s=i(n),u=a,b=s[c+"."+u]||s[u]||l[u]||o;return n?r.a.createElement(b,Object.assign({},{ref:t},p,{components:n})):r.a.createElement(b,Object.assign({},{ref:t},p))}));function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=s;var c={};for(var l in t)hasOwnProperty.call(t,l)&&(c[l]=t[l]);c.originalType=e,c[p]="string"==typeof e?e:a,i[1]=c;for(var u=2;u<o;u++)i[u]=n[u];return r.a.createElement.apply(null,i)}return r.a.createElement.apply(null,n)}s.displayName="MDXCreateElement"}}]);