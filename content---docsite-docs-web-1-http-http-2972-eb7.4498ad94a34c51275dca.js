(window.webpackJsonp=window.webpackJsonp||[]).push([[70],{162:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return p})),n.d(t,"rightToc",(function(){return a})),n.d(t,"default",(function(){return s}));n(0);var l=n(249);function r(){return(r=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var l in n)Object.prototype.hasOwnProperty.call(n,l)&&(e[l]=n[l])}return e}).apply(this,arguments)}function c(e,t){if(null==e)return{};var n,l,r=function(e,t){if(null==e)return{};var n,l,r={},c=Object.keys(e);for(l=0;l<c.length;l++)n=c[l],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var c=Object.getOwnPropertySymbols(e);for(l=0;l<c.length;l++)n=c[l],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p={id:"http2",title:"HTTP2",sidebar_label:"HTTP2"},a=[{value:"简介",id:"简介",children:[]},{value:"多路复用",id:"多路复用",children:[]},{value:"服务器推送",id:"服务器推送",children:[]},{value:"头部压缩",id:"头部压缩",children:[]}],b={rightToc:a},o="wrapper";function s(e){var t=e.components,n=c(e,["components"]);return Object(l.b)(o,r({},b,n,{components:t,mdxType:"MDXLayout"}),Object(l.b)("h2",{id:"简介"},"简介"),Object(l.b)("p",null,"HTTP/2主要目的是提高网页性能，最近几年比较火，将其单独抽成一块讲。2015年，HTTP/2 发布。它不叫 HTTP/2.0，是因为标准委员会不打算再发布子版本了，下一个新版本将是 HTTP/3。"),Object(l.b)("p",null,"目前还有不少服务还是HTTP/1.1，NodeJS也是从v10才将http2转正。Express5.x才开始支持http/2。"),Object(l.b)("p",null,Object(l.b)("img",r({parentName:"p"},{src:"https://cosmos-x.oss-cn-hangzhou.aliyuncs.com/ilnweH.png",alt:null}))),Object(l.b)("p",null,"可以打开谷歌首页看看，基本上都是http/2协议，简写成h2"),Object(l.b)("p",null,Object(l.b)("img",r({parentName:"p"},{src:"https://cosmos-x.oss-cn-hangzhou.aliyuncs.com/yRkSCa.png",alt:null}))),Object(l.b)("p",null,"HTTPS是HTTP/2的必要条件。"),Object(l.b)("p",null,"可以用Chrome插件可以用来检测HTTP/2：HTTP/2 and SPDY indicator。它会给浏览器添加了一个闪电标记："),Object(l.b)("img",{src:"https://raw.githubusercontent.com/ThinkBucket/oss/master/oMRy7v.png",width:"500",height:"50"}),Object(l.b)("br",null),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("p",{parentName:"li"},"蓝色闪电，表示这个网页是运行在HTTP/2上")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("p",{parentName:"li"},"红色闪电表示网页运行在SPDY上（spdy和h2的关系和参考这篇文章：",Object(l.b)("a",r({parentName:"p"},{href:"http://www.ruanyifeng.com/blog/2016/08/http.html"}),"HTTP 协议入门"),"）")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("p",{parentName:"li"},"灰色闪电则表示着这个网页既不是运行于HTTP/2，也不是运行于SPDY"))),Object(l.b)("p",null,"HTTP/1.1 版的",Object(l.b)("strong",{parentName:"p"},"头信息"),"肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，",Object(l.b)("strong",{parentName:"p"},"头信息和数据体都是二进制"),'，并且统称为"帧"（frame）：头信息帧和数据帧。\n',Object(l.b)("img",r({parentName:"p"},{src:"https://cosmos-x.oss-cn-hangzhou.aliyuncs.com/WQmV6R.png",alt:null}))),Object(l.b)("p",null,Object(l.b)("img",r({parentName:"p"},{src:"https://cosmos-x.oss-cn-hangzhou.aliyuncs.com/ixFt4p.png",alt:null})),"\n二进制的一个好处是，可以定义额外的帧。HTTP/2 定义了近十种帧，为将来的高级应用打好了基础。如果使用文本实现这种功能，解析数据将会变得非常麻烦，二进制解析则方便得多。"),Object(l.b)("h2",{id:"多路复用"},"多路复用"),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"原来是同一个 TCP 连接里面"),"，上一个回应（response）发送完了，服务器才能发送下一个，现在多路复用（Multiplexing）允许单一的 HTTP/2 连接同时发起多重的请求-响应消息。"),Object(l.b)("img",{src:"https://cosmos-x.oss-cn-hangzhou.aliyuncs.com/xIKbUs.png",width:"420",height:"420"}),Object(l.b)("br",null),Object(l.b)("p",null,"整个访问流程第一次请求index.html页面,之后浏览器会去请求style.css和scripts.js的文件。左边的图是顺序加载两个个文件的，右边则是并行加载两个文件。"),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"我们知道HTTP底层其实依赖的是TCP协议，那问题是在同一个连接里面同时发生两个请求响应着是怎么做到的？")),Object(l.b)("p",null,"首先你要知道，TCP连接相当于两根管道（一个用于服务器到客户端，一个用于客户端到服务器），管道里面数据传输是通过字节码传输，传输是有序的，每个字节都是一个一个来传输。"),Object(l.b)("p",null,"例如客户端要向服务器发送Hello、World两个单词，只能是先发送Hello再发送World，没办法同时发送这两个单词。不然服务器收到的可能就是HWeolrllod（注意是穿插着发过去了，但是顺序还是不会乱）。这样服务器就懵b了。"),Object(l.b)("p",null,"接上面的问题，能否同时发送Hello和World两个单词呢？当然也是可以的，可以将数据拆成包，给每个包打上标签。发的时候是这样的①H ②W ①e ②o ①l ②r ①l ②l ①o ②d。这样到了服务器，服务器根据标签把两个单词区分开来。实际的发送效果如下图："),Object(l.b)("p",null,"多路复用就是为了解决上述keep-alive的两个性能问题，我们来看一下，他是如何解决的。"),Object(l.b)("p",null,"解决第一个：在HTTP1.1的协议中，我们传输的request和response都是基本于文本的，这样就会引发一个问题：",Object(l.b)("strong",{parentName:"p"},"所有的数据必须按顺序传输"),"，比如需要传输：hello world，只能从h到d一个一个的传输，不能并行传输，因为接收端并不知道这些字符的顺序，所以并行传输在HTTP1.1是不能实现的。"),Object(l.b)("p",null,Object(l.b)("img",r({parentName:"p"},{src:"https://cosmos-x.oss-cn-hangzhou.aliyuncs.com/93XEwT.png",alt:null}))),Object(l.b)("p",null,"HTTP/2引入 ",Object(l.b)("strong",{parentName:"p"},"二进制数据帧和流"),"的概念，其中帧对数据进行顺序标识，如下图所示，这样浏览器收到数据之后，就可以按照序列对数据进行合并，而不会出现合并后数据错乱的情况。同样是因为有了序列，服务器就可以并行的传输数据，这就是流所做的事情。"),Object(l.b)("p",null,Object(l.b)("img",r({parentName:"p"},{src:"https://cosmos-x.oss-cn-hangzhou.aliyuncs.com/939SIN.png",alt:null}))),Object(l.b)("p",null,"解决第二个问题：HTTP/2对同一域名下所有请求都是基于流，也就是说同一域名不管访问多少文件，也只建立一路连接。同样Apache的最大连接数为300，因为有了这个新特性，最大的并发就可以提升到300，比原来提升了6倍！"),Object(l.b)("p",null,"HTTP 性能优化的关键并不在于高带宽，而是低延迟。TCP 连接会随着时间进行自我「调谐」，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐则被称为 TCP 慢启动。由于这种原因，让原本就具有突发性和短时性的 HTTP 连接变的十分低效。"),Object(l.b)("p",null,"HTTP/2 通过让所有数据流共用同一个连接，可以更有效地使用 TCP 连接，让高带宽也能真正的服务于 HTTP 的性能提升。"),Object(l.b)("p",null,"Demo: ",Object(l.b)("a",r({parentName:"p"},{href:"https://http2.akamai.com/demo"}),"https://http2.akamai.com/demo")," 通过下面两张图，我们可以更加深入的认识多路复用："),Object(l.b)("p",null,Object(l.b)("img",r({parentName:"p"},{src:"https://cosmos-x.oss-cn-hangzhou.aliyuncs.com/yMOMBv.png",alt:null}))),Object(l.b)("p",null,Object(l.b)("img",r({parentName:"p"},{src:"https://cosmos-x.oss-cn-hangzhou.aliyuncs.com/odScPl.png",alt:null}))),Object(l.b)("p",null,"以前我们做的性能优化不适用于HTTP/2了？"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"JS文件的合并"),"。我们现在优化的一个主要方向就是 ",Object(l.b)("strong",{parentName:"li"},"尽量的减少HTTP的请求数"),"， 对我们工程中的代码，研发时分模块开发，上线时我们会把所有的代码进行压缩合并，合并成一个文件，这样不管多少模块，都请求一个文件，减少了HTTP的请求数。但是这样做有一个非常严重的问题：",Object(l.b)("strong",{parentName:"li"},"文件的缓存"),"。当我们有100个模块时，有一个模块改了东西，按照之前的方式，整个文件浏览器都需要重新下载，不能被缓存。现在我们有了HTTP/2了，模块就可以单独的压缩上线，而不影响其他没有修改的模块。"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"多域名提高浏览器的下载速度"),"。之前我们有一个优化就是把css文件和js文件放到2个域名下面，这样浏览器就可以对这两个类型的文件进行同时下载，避免了浏览器6个通道的限制，这样做的缺点也是明显的，1.DNS的解析时间会变长。2.增加了服务器的压力。有了HTTP/2之后，根据上面讲的原理，我们就不用这么搞了，成本会更低。")),Object(l.b)("p",null,"总结下：多路复用技术：单连接多资源的方式，减少服务端的链接压力，内存占用更少，连接吞吐量更大；由于减少TCP 慢启动时间，提高传输的速度。"),Object(l.b)("h2",{id:"服务器推送"},"服务器推送"),Object(l.b)("p",null,"服务器推送（server push）指的是，还没有收到浏览器的请求，服务器就把各种资源推送给浏览器。"),Object(l.b)("p",null,"比如，浏览器只请求了index.html，但是服务器把index.html、style.css、example.png全部发送给浏览器。这样的话，只需要一轮 HTTP 通信，浏览器就得到了全部资源，提高了性能。"),Object(l.b)("p",null,Object(l.b)("img",r({parentName:"p"},{src:"https://cosmos-x.oss-cn-hangzhou.aliyuncs.com/B3hs9d.png",alt:null}))),Object(l.b)("p",null,"如何开启呢，可以在服务器配置里面写死要推送的资源，当然这样不是很灵活，那么可以用另一种方法：后端应用产生 HTTP 请求的头信息Link命令。服务器发现有这个头信息，就会进行服务器推送。"),Object(l.b)("pre",null,Object(l.b)("code",r({parentName:"pre"},{}),"Link: </styles.css>; rel=preload; as=style\n")),Object(l.b)("p",null,"如果要推送多个资源，就写成下面这样。"),Object(l.b)("pre",null,Object(l.b)("code",r({parentName:"pre"},{}),"Link: </styles.css>; rel=preload; as=style, </example.png>; rel=preload; as=image\n")),Object(l.b)("p",null,"可以参考 ",Object(l.b)("a",r({parentName:"p"},{href:"https://ops.tips/blog/nginx-http2-server-push/"}),"Go"),"、",Object(l.b)("a",r({parentName:"p"},{href:"https://blog.risingstack.com/node-js-http-2-push/"}),"Node")," 实现范例。"),Object(l.b)("p",null,"服务器推送有一个很麻烦的问题。所要推送的资源文件，如果浏览器已经有缓存，推送就是浪费带宽。即使推送的文件版本更新，浏览器也会优先使用本地缓存。"),Object(l.b)("p",null,"一种解决办法是，只对第一次访问的用户开启服务器推送，可以根据 Cookie 判断是否为第一次访问。"),Object(l.b)("p",null,"服务器推送可以提高性能。",Object(l.b)("a",r({parentName:"p"},{href:"https://www.smashingmagazine.com/2017/04/guide-http2-server-push/#measuring-server-push-performance"}),"网上测评"),"的结果是，打开这项功能，比不打开时的 HTTP/2 快了8%，比将资源都嵌入网页的 HTTP/1 快了5%。提升程度也不是特别多，大概是几百毫秒。而且，也不建议一次推送太多资源，这样反而会拖累性能，因为浏览器不得不处理所有推送过来的资源。只推送 CSS 样式表可能是一个比较好的选择。"),Object(l.b)("h2",{id:"头部压缩"},"头部压缩"),Object(l.b)("p",null,"在HTTP/1.x中首部是没有压缩的，gzip只会压缩body，HTTP/2提供了首部压缩方案。一般轮询请求首部，特别是cookie占用很多大部份空间，首部压缩使得整个HTTP数据包小了很多，传输也就会更快。还有一些浏览器的信息，这些每个请求基本上都一样，没必要每次都传一份完整的。"),Object(l.b)("p",null,"HTTP/2使用专门设计的HPACK。它是在服务器和客户端各维护一个“首部表”，表中用索引代表首部名，或者首部键-值对，上一次发送两端都会记住已发送过哪些首部，下一次发送只需要传输差异的数据，相同的数据直接用索引表示即可，另外还可以选择地对首部值压缩后再传输。按照这样的设计，两次轮询请求的首部基本是一样的，那之后的请求基本只需要发送几个索引就可以了。\n",Object(l.b)("img",r({parentName:"p"},{src:"https://cosmos-x.oss-cn-hangzhou.aliyuncs.com/WIKfnl.png",alt:null}))),Object(l.b)("p",null,"“首部表”有两种，一种是静态表，即HTTP/2协议内置了常用的一些首部名和首部键值对。另一种是动态表，保存自定义的首部或五花八门的键值对等，动态表可以通过SETTINGS帧的SETTINGS_HEADER_TABLE_SIZE规定大小。"),Object(l.b)("p",null,"想更深地了解HTTP/2是什么？建议你前往："),Object(l.b)("p",null,Object(l.b)("a",r({parentName:"p"},{href:"https://hpbn.co/http2/"}),"High Performance Browser Networking-HTTP/2 O'Reilly")),Object(l.b)("p",null,Object(l.b)("a",r({parentName:"p"},{href:"https://www.rrfed.com/2018/03/18/chrome-http2/"}),"https://www.rrfed.com/2018/03/18/chrome-http2/")),Object(l.b)("p",null,Object(l.b)("img",r({parentName:"p"},{src:"https://cosmos-x.oss-cn-hangzhou.aliyuncs.com/LP9NmA.png",alt:null}))))}s.isMDXComponent=!0},249:function(e,t,n){"use strict";n.d(t,"a",(function(){return a})),n.d(t,"b",(function(){return u}));var l=n(0),r=n.n(l),c=r.a.createContext({}),p=function(e){var t=r.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):Object.assign({},t,e)),n},a=function(e){var t=p(e.components);return r.a.createElement(c.Provider,{value:t},e.children)};var b="mdxType",o={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},s=Object(l.forwardRef)((function(e,t){var n=e.components,l=e.mdxType,c=e.originalType,a=e.parentName,b=function(e,t){var n={};for(var l in e)Object.prototype.hasOwnProperty.call(e,l)&&-1===t.indexOf(l)&&(n[l]=e[l]);return n}(e,["components","mdxType","originalType","parentName"]),s=p(n),u=l,i=s[a+"."+u]||s[u]||o[u]||c;return n?r.a.createElement(i,Object.assign({},{ref:t},b,{components:n})):r.a.createElement(i,Object.assign({},{ref:t},b))}));function u(e,t){var n=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var c=n.length,p=new Array(c);p[0]=s;var a={};for(var o in t)hasOwnProperty.call(t,o)&&(a[o]=t[o]);a.originalType=e,a[b]="string"==typeof e?e:l,p[1]=a;for(var u=2;u<c;u++)p[u]=n[u];return r.a.createElement.apply(null,p)}return r.a.createElement.apply(null,n)}s.displayName="MDXCreateElement"}}]);