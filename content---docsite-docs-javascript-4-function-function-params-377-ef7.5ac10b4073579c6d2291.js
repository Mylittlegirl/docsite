(window.webpackJsonp=window.webpackJsonp||[]).push([[59],{150:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return o})),t.d(n,"rightToc",(function(){return b})),t.d(n,"default",(function(){return u}));t(0);var a=t(390);function r(){return(r=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e}).apply(this,arguments)}function c(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},c=Object.keys(e);for(a=0;a<c.length;a++)t=c[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var c=Object.getOwnPropertySymbols(e);for(a=0;a<c.length;a++)t=c[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var o={title:"函数参数",sidebar_label:"函数参数"},b=[{value:"传参方式",id:"传参方式",children:[]},{value:"参数默认值",id:"参数默认值",children:[]}],l={rightToc:b},i="wrapper";function u(e){var n=e.components,t=c(e,["components"]);return Object(a.b)(i,r({},l,t,{components:n,mdxType:"MDXLayout"}),Object(a.b)("h2",{id:"传参方式"},"传参方式"),Object(a.b)("p",null,"JS 粗略的说是按值传递，准确的说，JS中的原始类型按值传递，引用类型按共享传递的(call by sharing，也叫按对象传递、按对象共享传递，本质上也是按值传递)。最早由Barbara Liskov. 在1974年的GLU语言中提出。该求值策略被用于Python、Java、Ruby、JS等多种语言。"),Object(a.b)("p",null,"归纳到一起可以说是按值传递，本质上传递的是变量的值的拷贝。请注意，这里所说的按值传递不是传统意义上的按值传递，在JS中一切都要区分是基础类型还是引用类型，JS基本上都在遵守这个原则（比如浅拷贝、深拷贝），当然函数传参也不例外，一定要区分变量类型，这是前提。"),Object(a.b)("div",{align:"center"},Object(a.b)("img",{width:"330",src:"https://cosmos-x.oss-cn-hangzhou.aliyuncs.com/wVo2dl.jpg"})),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("strong",{parentName:"li"},"原始类型"),"：传统的按值传递，拷贝的是实际的值，拷贝一份从此各奔东西。"),Object(a.b)("li",{parentName:"ul"},Object(a.b)("strong",{parentName:"li"},"引用类型"),"：值指的是该对象所指向的内存地址的值的拷贝，拷贝了一个对象快捷方式，而不是其所代表的实际值。",Object(a.b)("ul",{parentName:"li"},Object(a.b)("li",{parentName:"ul"},Object(a.b)("strong",{parentName:"li"},"修改变量的某个属性"),"，原始对象也会修改。"),Object(a.b)("li",{parentName:"ul"},Object(a.b)("strong",{parentName:"li"},"将该对象重新赋值"),"，原始对象不改，相当于与原始对象“断链”，也是从此各奔东西。")))),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),'function changeStuff(a, b, c) {\n a = a * 10;\n b.item = "changed";\n c = { item: "changed" };\n}\n\nvar num = 10;\nvar obj1 = { item: "unchanged" };\nvar obj2 = { item: "unchanged" };\n\nchangeStuff(num, obj1, obj2);\n\nconsole.log(num); //10\nconsole.log(obj1.item); //changed\nconsole.log(obj2.item); //unchanged\n')),Object(a.b)("p",null,"几种传值方式："),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("strong",{parentName:"li"},"按值传递（Pass by value）"),"：在按值传递中，传递给函数参数是函数被调用时所传实参的拷贝。在按值传递中实际参数被求值，其值被绑定到函数中对应的变量上（通常是把值复制到新内存区域）"),Object(a.b)("li",{parentName:"ul"},Object(a.b)("strong",{parentName:"li"},"按引用传递（Pass by reference）"),"：在按引用传递中，传递给函数的是它的实际参数的隐式引用而不是实参的拷贝。通常函数能够修改这些参数（比如赋值），而且改变对于调用者是可见的。"),Object(a.b)("li",{parentName:"ul"},Object(a.b)("strong",{parentName:"li"},"传共享调用（Call by sharing）"),"：还有一种求值策略叫做传共享调用（Call-by-sharing/Call by object/Call by object-sharing）。传共享调用和传引用调用的不同之处是，该求值策略传递给函数的参数是对象的引用的拷贝，即对象变量地址的拷贝。")),Object(a.b)("h4",{id:"1-变量初始化"},"1. 变量初始化"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),'var num = 10;\nvar obj1 = { item: "unchanged" };\nvar obj2 = { item: "unchanged" };\n')),Object(a.b)("div",{align:"center"},Object(a.b)("img",{width:"600",src:"https://cosmos-x.oss-cn-hangzhou.aliyuncs.com/CsgaPj.jpg"})),Object(a.b)("h4",{id:"2调用函数"},"2.调用函数"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),"changeStuff(num, obj1, obj2);\n")),Object(a.b)("div",{align:"center"},Object(a.b)("img",{width:"600",src:"https://cosmos-x.oss-cn-hangzhou.aliyuncs.com/m49aQl.jpg"})),Object(a.b)("h4",{id:"3执行函数体"},"3.执行函数体"),Object(a.b)("pre",null,Object(a.b)("code",r({parentName:"pre"},{className:"language-js"}),'a = a * 10;\nb.item = "changed";\nc = { item: "changed" };\n')),Object(a.b)("div",{align:"center"},Object(a.b)("img",{width:"600",src:"https://cosmos-x.oss-cn-hangzhou.aliyuncs.com/MfyA1P.jpg"})),Object(a.b)("h2",{id:"参数默认值"},"参数默认值"),Object(a.b)("p",null,"ES6借鉴了python的语法，主要两点：1，对象嵌套多层结构，如何设置内层默认值。2，可不可以像python一样跨位置传参，不然，后面的位置还要补齐前面位置的值。"))}u.isMDXComponent=!0},390:function(e,n,t){"use strict";t.d(n,"a",(function(){return b})),t.d(n,"b",(function(){return s}));var a=t(0),r=t.n(a),c=r.a.createContext({}),o=function(e){var n=r.a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):Object.assign({},n,e)),t},b=function(e){var n=o(e.components);return r.a.createElement(c.Provider,{value:n},e.children)};var l="mdxType",i={inlineCode:"code",wrapper:function(e){var n=e.children;return r.a.createElement(r.a.Fragment,{},n)}},u=Object(a.forwardRef)((function(e,n){var t=e.components,a=e.mdxType,c=e.originalType,b=e.parentName,l=function(e,n){var t={};for(var a in e)Object.prototype.hasOwnProperty.call(e,a)&&-1===n.indexOf(a)&&(t[a]=e[a]);return t}(e,["components","mdxType","originalType","parentName"]),u=o(t),s=a,p=u[b+"."+s]||u[s]||i[s]||c;return t?r.a.createElement(p,Object.assign({},{ref:n},l,{components:t})):r.a.createElement(p,Object.assign({},{ref:n},l))}));function s(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var c=t.length,o=new Array(c);o[0]=u;var b={};for(var i in n)hasOwnProperty.call(n,i)&&(b[i]=n[i]);b.originalType=e,b[l]="string"==typeof e?e:a,o[1]=b;for(var s=2;s<c;s++)o[s]=t[s];return r.a.createElement.apply(null,o)}return r.a.createElement.apply(null,t)}u.displayName="MDXCreateElement"}}]);