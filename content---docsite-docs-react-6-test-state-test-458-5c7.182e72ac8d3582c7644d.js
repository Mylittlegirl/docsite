(window.webpackJsonp=window.webpackJsonp||[]).push([[52],{132:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"rightToc",(function(){return i})),n.d(t,"default",(function(){return p}));n(0);var a=n(179);function c(){return(c=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e}).apply(this,arguments)}function r(e,t){if(null==e)return{};var n,a,c=function(e,t){if(null==e)return{};var n,a,c={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(c[n]=e[n]);return c}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(c[n]=e[n])}return c}var o={id:"state-test",title:"状态测试",sidebar_label:"状态测试"},i=[{value:"Action Test",id:"action-test",children:[{value:"同步 action",id:"同步-action",children:[]},{value:"异步 action",id:"异步-action",children:[]}]},{value:"Reducer Test",id:"reducer-test",children:[]},{value:"Selector Test",id:"selector-test",children:[]}],s={rightToc:i},l="wrapper";function p(e){var t=e.components,n=r(e,["components"]);return Object(a.b)(l,c({},s,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("p",null,"在 React App 的开发过程中，我们将状态测试主要分为 Action Test、Reducer Test 和 Selector Test。"),Object(a.b)("h2",{id:"action-test"},"Action Test"),Object(a.b)("h3",{id:"同步-action"},"同步 action"),Object(a.b)("p",null,"sync action 的单元测试相对比较简单，主要测试 action creator 的返回值是否正确，示例代码："),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-javascript"}),"describe('#action# setDiscountType', () => {\n    const lineId = '456adc81-7b5a-4863-95b1-b43d1539a233';\n    const discountType = 0;\n    it('should return setDiscountType action creator correctly', () => {\n        const action = setDiscountType(lineId, discountType);\n        expect(action).to.have.property('type', actionTypes.LINES_SET_REQUEST);\n        expect(action).to.have.property('lineId', lineId);\n        expect(action).to.have.property('discountType', discountType);\n    });\n}\n")),Object(a.b)("h3",{id:"异步-action"},"异步 action"),Object(a.b)("p",null,"async action 的单元测试相对比较复杂，结合项目中的 redux-thunk 进行测试，主要测试异步 action 中的REQUEST、SUCCESS、ERROR 在不同情况下是否按照预期进行调用，示例代码："),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-javascript"}),"describe('#action# setLinesData', () => {\n    const dispatch = jest.fn();\n    const lineId = '456adc81-7b5a-4863-95b1-b43d1539a233';\n    const lineData = {...};\n    const getState = jest.fn().mockReturnValue(Immutable({...}));\n\n    afterEach(jest.clearAllMocks);\n\n    it('should set lines data success', done => {\n        const utils = {\n            ProformaService: {\n                setLinesData: jest.fn().mockReturnValue(Promise.resolve())\n            }\n        };\n        setLinesData(lineId, false, lineData)(dispatch, getState, utils)\n            .then(() => {\n                expect(dispatch).toHaveBeenCalledWith({\n                    type: actionTypes.LINES_SET_REQUEST\n                });\n                expect(dispatch).toHaveBeenCalledWith({\n                    type: actionTypes.LINES_SET_SUCCESS\n                });\n                done();\n            })\n            .catch(done.fail);\n    });\n}\n")),Object(a.b)("p",null,"函数中的业务逻辑，需要根据具体的情况进行测试。"),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},Object(a.b)("strong",{parentName:"p"},"强制"),"：异步 action 的测试一定要向其传入并执行 done 函数， Jest 会等 done 回调执行结束后，结束测试。否则 test 会显示通过，但有错误，也失去了测试的意义。")),Object(a.b)("h2",{id:"reducer-test"},"Reducer Test"),Object(a.b)("p",null,"reducer 的测试一般是期望 ",Object(a.b)("inlineCode",{parentName:"p"},"reducer(state, action) === newState"),"，其实这种方式和 ",Object(a.b)("inlineCode",{parentName:"p"},"(input) => output")," 的模式是一样的。"),Object(a.b)("p",null,"测试 state 首先要引入 Immutable 保证状态树的不可变性，示例代码："),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-javascript"}),"import Immutable from 'seamless-immutable';\n\nconst initialState = Immutable({...});\nconst action = { type: ..., payload: ...};\nconst expectedState = {...};\n\nexpect(reducer(initialState, action)).toEqual(expectedState);\n")),Object(a.b)("h2",{id:"selector-test"},"Selector Test"),Object(a.b)("p",null,"Selector Test 其实也是 ",Object(a.b)("inlineCode",{parentName:"p"},"(input) => output")," 这种模式，同样测试的时候也要引入 Immutable 来保证状态树的不可变性，示例代码："),Object(a.b)("pre",null,Object(a.b)("code",c({parentName:"pre"},{className:"language-javascript"}),"import Immutable from 'seamless-immutable';\n\nconst state = Immutable({...});\nconst expectedprops = {...};\n\nexpect(selector.getLines(state)).toEqual(expectedprops);\n")))}p.isMDXComponent=!0},179:function(e,t,n){"use strict";n.d(t,"a",(function(){return i})),n.d(t,"b",(function(){return u}));var a=n(0),c=n.n(a),r=c.a.createContext({}),o=function(e){var t=c.a.useContext(r),n=t;return e&&(n="function"==typeof e?e(t):Object.assign({},t,e)),n},i=function(e){var t=o(e.components);return c.a.createElement(r.Provider,{value:t},e.children)};var s="mdxType",l={inlineCode:"code",wrapper:function(e){var t=e.children;return c.a.createElement(c.a.Fragment,{},t)}},p=Object(a.forwardRef)((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,i=e.parentName,s=function(e,t){var n={};for(var a in e)Object.prototype.hasOwnProperty.call(e,a)&&-1===t.indexOf(a)&&(n[a]=e[a]);return n}(e,["components","mdxType","originalType","parentName"]),p=o(n),u=a,b=p[i+"."+u]||p[u]||l[u]||r;return n?c.a.createElement(b,Object.assign({},{ref:t},s,{components:n})):c.a.createElement(b,Object.assign({},{ref:t},s))}));function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,o=new Array(r);o[0]=p;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i[s]="string"==typeof e?e:a,o[1]=i;for(var u=2;u<r;u++)o[u]=n[u];return c.a.createElement.apply(null,o)}return c.a.createElement.apply(null,n)}p.displayName="MDXCreateElement"}}]);